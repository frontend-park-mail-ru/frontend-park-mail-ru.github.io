---
layout: default
title: Архитектура
---

{::options auto_ids="false" /}

[ГЛАВНАЯ](/)

# 1 Архитектура
{: id="1"}

Содержание:

1.1 [Знакомство, инструменты, настройка окружения](#1.1)

1.1.1 [Полезные ресурсы](#1.1.1)\\
1.1.2 [Смешанное занятие](#1.1.2)\\
1.1.3 [Домашнее задание](#1.1.3)\\
1.1.4 [Техническое задание](#1.1.4)
{:.toc}

1.2 [Архитектура веб-приложений](#1.2)

1.2.1 [Полезные ресурсы](#1.2.1)\\
1.2.2 [Смешанное занятие](#1.2.2)\\
1.2.3 [Домашнее задание](#1.2.3)\\
1.2.4 [Техническое задание](#1.2.4)
{:.toc}

1.3 [Авторизация. Регистрация. Редактировани данных пользователя, AJAX, HTML form 4](#1.3)

1.3.1 [Полезные ресурсы](#1.3.1)\\
1.3.2 [Лекция](#1.3.2)\\
1.3.3 [Домашнее задание](#1.3.3)\\
1.3.4 [Техническое задание](#1.3.4)
{:.toc}

## 1.1 Знакомство, инструменты, настройка окружения
{: id="1.1"}

### 1.1.1 Полезные ресурсы
{: id="1.1.1"}

1. Scott Chacon. [Pro Git](http://git-scm.com/book) // 2009.
2. [Grunt: Getting started](http://gruntjs.com/getting-started) // 2013.
3. Документация по [NPM](https://npmjs.org/doc/cli/npm.html) и [`package.json`](https://npmjs.org/doc/files/package.json.html).
4. Документация по шаблонизатору [Fest](https://github.com/mailru/fest).
5. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.

### 1.1.2 Смешанное занятие
{: id="1.1.2"}

Меня зовут Иван Чашкин, в компании Mail.ru я занимаюсь разработкой веб-версии мобильной почты для смартфонов. Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Артем Мезин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Артем занимается разработкой основной версией почты.

Курс фронтенд разработки состоит из трех модулей, шести совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), пяти лекций, четырех контрольных рубежей и защиты проекта. В общей сложности курс состоит из шестнадцати занятий.

Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.

Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.

Дадим определение основных понятий.

> Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [[Википедия](http://ru.wikipedia.org/wiki/Веб-приложение)].

Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – frontend, тогда как часть веб-приложения, работающая на стороне сервера, называется backend.

В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, AJAX; получите необходимую базу знаний о работе браузера (десктопного и мобильныого), клиент-серверной архитектуре, архитектуре веб-приложений и приобретёте  навыки работы с DOM и Host Objetcs, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.

Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для однопользовательской игры с использованием смартфона в качестве игрового контроллера.

На протяжении всего семестра у вас будет четыре контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопровождается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. На каждом контрольным рубеже сначала принимаются текущие работы, а уже затем, если остается время, работы с предыдущих рубежей. Итоговый рейтинг по дисциплине представляет собой сумму баллов, полученных за прохождение рубежных контролей и домашних заданий. Для успешной аттестации по данному курсу студентам необходимо набрать пороговый рейтинг — 70 баллов. При пересчете баллов студенты могут получить итоговую оценку: 0–69 неудовлетворительно, 70–84 удовлетворительно, 85–99 хорошо, 100 отлично.

Каковы критерии оценки при прохождении рубежного контроля?

1. Соответствие результата предъявляемым требованиям.
2. Оптимальность предлагаемого решения.
3. Практичность решения (возможность дальнейшего применения в работе).
4. Качество оформления результатов работы.
5. Доказательность аргументации при защите работы.

Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).

Вводная часть занятия окончена. Переходим в основной части.

Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом [Node.js](http://nodejs.org) появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является [самым популярным языком программирования](http://adambard.com/blog/top-github-languages-for-2013-so-far/) среди создаваемых на GitHub проектов.

Вместе с дистрибутивом Node.js распространяется и [NPM](https://npmjs.org) (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.

В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на [GitHub](https://github.com/eprev/frontend).

У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является [Grunt](http://gruntjs.com/). Его без труда может установить каждый, воспользовавшись NPM.

Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. [Fest](https://github.com/mailru/fest) обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.

Создайте директорию для проекта.

~~~
$ mkdir epicgame
~~~

Создайте [`package.json`](https://npmjs.org/doc/files/package.json.html).

~~~
$ npm init
~~~

Установите Grunt и `grunt-shell`.

~~~
$ npm install grunt-cli -g
$ npm install grunt grunt-shell --save-dev
~~~

Создайте `Gruntfile.js` и настройте таск `shell`.

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        shell: {
            options: {
                stdout: true,
                stderr: true
            },
            server: {
                command: 'java -cp L1.2-1.0-jar-with-dependencies.jar main.Main 8080' /* запуск сервера */
            }
        }
    });

    grunt.loadNpmTasks('grunt-shell');

};
~~~
{:.javascript}

~~~
$ grunt connect
Running "shell:server" (shell) task
Starting at port: 8000
...
~~~

Создайте `public_html/index.html`.

Установите `grunt-fest` и настройте таск `fest`.

~~~
$ npm install grunt-fest --save-dev
~~~

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        shell: {
            options: {
                stdout: true,
                stderr: true
            },
            server: {
                command: 'java -cp L1.2-1.0-jar-with-dependencies.jar main.Main 8080'
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates', /* исходная директория */
                    src: '*.xml', /* имена шаблонов */
                    dest: 'public_html/js/tmpl' /* результирующая директория */
                }],
                options: {
                    template: function (data) { /* задаем формат функции-шаблона */
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;', /* присваиваем функцию-шаблон переменной */
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-shell');
    grunt.loadNpmTasks('grunt-fest');

};
~~~
{:.javascript}

Установите `grunt-contrib-watch` и настройте таск `watch`.

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'],
                tasks: ['fest'],
                options: {
                    interrupt: true,
                    atBegin: true
                }
            }
        },
        shell: {
            options: {
                stdout: true,
                stderr: true
            },
            server: {
                command: 'java -cp L1.2-1.0-jar-with-dependencies.jar main.Main 8080'
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public_html/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-shell');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['shell', 'watch']); /* задача по умолчанию */

};
~~~
{:.javascript}

Установите `grunt-concurrent` и настройте таск `concurrent`.

~~~
    concurrent: {
            target: ['watch', 'shell'],
            options: {
                logConcurrentOutput: true /* Вывод логов */
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-concurrent');
    grunt.loadNpmTasks('grunt-shell');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['concurrent']);
~~~
{:.javascript}

Добавьте [`livereload`](https://github.com/gruntjs/grunt-contrib-watch#optionslivereload).

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'],
                tasks: ['fest'],
                options: {
                    atBegin: true
                }
            },
            server: {
                files: [
                    'public_html/js/**/*.js', /* следим за статикой */
                    'public_html/css/**/*.css'
                ],
                options: {
                    interrupt: true,
                    livereload: true /* перезагрузить страницу */
                }
            }
        }
        ...
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-concurrent');
    grunt.loadNpmTasks('grunt-shell');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['concurrent']);

};
~~~
{:.javascript}

Включите Livereload.

~~~
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/css/main.css"/>
</head>
<body>
    <div id="page"></div>
    
    <!-- Livereload -->
    <script src="//localhost:35729/livereload.js"></script>
</body>
</html>
~~~
{:.html}

Подключите [jQuery](http://jquery.com). Создайте функции для отрисовки каждого из экранов игры.

~~~
var $page = $('#page');

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {}

/* Конструктор экрана "Авторизация" */
function showLoginScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Авторизация" */
function hideLoginScreen() {}

/* Конструктор экрана "Главный" */
function showMainScreen() {
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
    $page.find('.js-login').on('click', showLoginScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
    $page.find('.js-login').off('click', showLoginScreen);
}

showMainScreen();
~~~
{:.javascript}

Заключительный вариант.

~~~
var $page = $('#page'),
    currentScreen = 'main';

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'scoreboard';
    $page.html(scoreboardTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'game';
    $page.html(gameTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Авторизация" */
function showLoginScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'login';
    $page.html(loginTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Авторизация" */
function hideLoginScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Главный" */
function showMainScreen() {
     // Убиваем текущий экран
    if (currentScreen === 'scoreboard') {
        hideScoreboardScreen();
    } else if (currentScreen === 'game') {
        hideGameScreen();
    } else if (currentScreen === 'login') {
        hideLoginScreen();
    }
    currentScreen = 'main';
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
    $page.find('.js-login').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
    $page.find('.js-login').off('click', showLoginScreen);
}

showMainScreen();
~~~
{:.javascript}

### 1.1.3 Домашнее задание
{: id="1.1.3"}

1. Сформировать идею игры.
2. Самостоятельно изучить документацию Grunt и сопутствующие расширения, Fest и jQuery.
3. Создать прототип веб-приложения.

### 1.1.4 Техническое задание
{: id="1.1.4"}

1. Прототип состоит из четырех экранов:
    1. Главный экран (Main Screen). Содержит название игры и пункты главного меню:
        - Пункт «Лучшие игроки» ведет на экран «Лучшие игроки».
        - Пункт «Авторизация» ведет на экран авторизации.
        - Пункт «Начать игру» ведет на основной экран игры.
    2. Лучшие игроки (Scoreboard Screen). Содержит название игры и кнопку «Назад», ведущую на главный экран.
    3. Экран авторизации содержит поля email, пароль и кнопку submit.
    4. Основной экран игры (Game Screen). Содержит кнопку «Назад», ведущую на главный экран.
2. За отрисовку и последующую инициализацию каждого экрана должна отвечать отдельная функция в JavaScript.
3. Со страницы авторизации форма должна отправлять post запрос по адресу "/api/v1/auth/signin".
4. При первой загрузке страницы с игрой появляется главный экран. Переход между экранами должен осуществлятся без перезагрузки страницы.
5. Для шаблонизации на строне клиента должен использоваться Fest (см. [`grunt-fest`](https://npmjs.org/package/grunt-fest) и [Fest](https://github.com/mailru/fest)).
6. С помощиью Grunt возможно запустить веб-сервер с игрой (см. [`grunt-shell`](https://npmjs.org/package/grunt-shell)). Страницу с игрой необходимо автоматически перезагружать при изменении исходных JavaScript, XML (Fest) или CSS файлов (см. параметр `livereload` в задаче и [`grunt-contrib-watch`](https://npmjs.org/package/grunt-contrib-watch)).

![Схема прототипа](/pics/prototype-scheme.png)

## 1.2 Архитектура веб-приложений
{: id="1.2"}

### 1.2.1 Полезные ресурсы
{: id="1.2.1"}

1. Addy Osmani. [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) // 2011.
2. Эдди Османи. [Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru) // 2011.
3. Addy Osmani. [Developing Backbone.js Applications](http://addyosmani.github.io/backbone-fundamentals/) // 2013.
4. Документация [Backbone.js](http://backbonejs.org).
5. Неофициальный перевод документации [Backbone.js](http://backbonejs.ru).
6. Документация [RequireJS](http://requirejs.org/).
7. Неофициальный перевод документации [RequireJS](http://requirejs.ru).
8. Документация [Underscore](http://underscorejs.org/).
9. Неофициальный перевод документации [Underscore](http://underscorejs.ru/).

### 1.2.2 Смешанное занятие
{: id="1.2.2"}

Сегодняшнее занятие будет посвящено устройству современных веб-приложений и хорошим практикам. Начнем с одной из них — работой с глобальной областью видимости в JavaScript.

Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Областью видимости локальных переменных является функция. Глобальные переменные являются свойствамии объекта `window`.

~~~
function quz() {
    foo = {}; /* глобальная переменная */
    window.foo === foo; /* true */
    var bar = {}; /* локальная переменная */
    window.bar === bar; /* false */
}
~~~
{:.javascript}

Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства `window`. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.

~~~
var foo = 1;
(function () {
    var foo = 2;
    alert(foo); // 2
})();
alert(foo); // 1
~~~
{:.javascript}

Конструкция в примере выше называется *немедленно-вызываемая функция* (Immediately-Invoked Function Expression, IIFE). Мы создаем анонимную функцию и незамедлительно вызываем ее, с параметрами или без.

Пока что наша функция ничего не возвращает, и модулем назвать ее сложно. Рассмотрим пример по сложнее.

~~~
var module = (function () {
        var name = 'A'; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(name); // 2
            }
        };
    })();
~~~
{:.javascript}

На этот раз немедленно-вызываемая функция возвращает объект, определяющий интерфейс модуля, с которым уже можно работать в других частях веб-приложения. Такой подход предотвращает попадание приватных переменных и функций в глобальный контекст, где они могут конфликтовать с другими интерфейсами.

В отличии от некоторых других языков программирования, JavaScript не поддерживает модификаторы доступа. Область видимости ограничивает доступность объявленных в ней переменных. Таким образом, объявленные внутри модуля переменные и функции доступны только изнутри этого модуля, а свойства объекта, возвращаемого модулем, будут доступны всем.

При разработке сервер-сайда веб-приложения популярен подход [MVC](http://ru.wikipedia.org/wiki/Model-View-Controller) (Model-View-Controller). Обработкой запроса к серверу занимается контроллер (Controller). Контроллер обращается за данными к модели (Model), которая общается с базой данных. Полученые от модели данные контроллер отправлят в представление (View) для формирования ответа на поступивший запрос.

![MVC сервер-сайда](/pics/mvc-ss.png)

Так вот, при разработке клиент-сайда больших веб-приложения тоже применяется подход MVC, но в действительности он работает по-другому. Во главе теперь стоит модель. При изменении своего состояния модель оповещает об этом всех слушателей. Представление это интерфейс, то что видит пользователь и с чем работает. Представление следит за изменения модели и реагирует на них. Но когда пользователь взаимодействует с представлением (например, выполнилняет click по кнопке), представление передает управление контроллеру. Последний в свою очередь вносит изменения в модель и все начинается сначала.

![MVC клиент-сайда](/pics/mvc-cs.png)

Как устроен клиент-сайд сложного веб-приложения?

Уровень библиотек.
Уровень ядра приложения.
Уровень модулей.

> Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [[Википедия](http://ru.wikipedia.org/wiki/Модуль_(программирование\))].

Модуль веб-приложения состоит из HTML, CSS и JavaScript. Модули характеризуются [связанностью](http://ru.wikipedia.org/wiki/Связанность_(программирование\)). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные.

Давайте посмотрим на одно из популярный веб-приложений — «Почту».

![Почта](/pics/email.png)

Веб-приложение состоит из многих модулей, вот некоторые из них.

Портальное меню (`portal-menu`).
![Модуль Портальное меню](/pics/email-portal-menu.png)

Тулбар (`toolbar`).
![Модуль Тулбар](/pics/email-toolbar.png)
![Модуль Тулбар](/pics/email-toolbar-2.png)

Навигация (`nav`).
![Модуль Навигация](/pics/email-nav.png)

Список писем (`letters`).
![Модуль Список писем](/pics/email-datalist.png)

Чтобы модули обладали слабой связанностью не только на уровне логическом (JavaScript), но и на уровне представления (CSS), мы в разработке придерживаемся методологии [БЭМ](http://ru.bem.info/).

Что такое БЭМ?

БЭМ расшифровывается как «Блок, Элемент, Модификатор». Это методология разработки веб-проектов, способ удобно делить интерфейс на отдельные блоки и элементы.

Модуль – это блок в терминологии БЭМ. Блок состоит из элементов или других блоков. Например блок `toolbar`, который показан на рисунках выше, состоит из элементов – кнопок `toolbar__button`.

Кнопка тулбара (`toolbar__button`).
![Элемент toolbar__button](/pics/email-toolbar__button.png)

Согласно БЭМ, в имени элемента обязательно должно присутствовать имя блока, которому он принадлежит, и для их разрграничения обычно используется два нижних подчеркивания. Сделано это для того, чтобы минимизировать количество контекстных селекторов при описании стилей блоков и элементов. Зачем это необходимо?

В качестве примера рассмотрим простейший пример реализации кнопки в тулбаре.

~~~
<div class="toolbar">
    <div class="button">Click Me</div>
</div>
~~~
{:.html}

~~~
.toolbar .button {
    background: white;
}
~~~
{:.css}

А теперь поместим этот тулбар в окошко, в котором тоже есть кнопки, но другие.

~~~
<div class="window">
    <div class="toolbar">
        <div class="button">Click Me</div>
    </div>
    <button class="button">Submit</button>
</div>
~~~
{:.html}

~~~
.toolbar .button {
    background: white;
}
.window .button {
    background: black;
}
~~~
{:.css}

Обе кнопки в примере выше будут черного цвета. Цвет кнопки внутри `toolbar` оказался перебит значением, заданным по умолчанию для кнопок внутри блока `window`. Мы оказались в ситуации, когда визуальное оформление элемента `button` блока `toolbar`, зависит от окружения, в которое помещен блок. БЭМ позволяет свести такие ситуации к нулю. За счет отказа от использования контекстных селекторов, мы достигаем практически нулевой связности между блоками, блоки становятся независимыми от того окружения, в котором они окажутся.

~~~
<div class="window">
    <div class="toolbar">
        <div class="toolbar__button">Click Me</div>
    </div>
    <button class="window__button">Submit</button>
</div>
~~~
{:.html}

~~~
.toolbar__button {
    background: white;
}
.window__button {
    background: black;
}
~~~
{:.css}

Теперь элементы `toolbar__button` и `window__button` являются независимыми. У таког подхода ко всему прочему есть еще один приятный момент — скорость отрисовки страниц. Чем сложнее селекторы в каскадной таблице стилей, тем больше времени браузер потратит на определение стилей элементов страницы. Так как, разбор составного селектора происходит справа налево, то есть сначала выбираются элементы, удовлетворяющие самому правому селектору, затем для каждого найдено элемента происходит поиск родительского, удовлетворяюего следующему селектору.

Одни и те же блоки и элементы не всегда выглядят одинаково в итерфейсе. Например, они могут отличаться геометрическими размерами или отличаться графическим содержанием (как это бывает с иконками у тех же самых кнопок). Для этих целей в БЭМ предусмотрены модификаторы. Модификатор это класс, который применяется дополнительно к блоку или элементу с целью изменения его представления. В имени модификатора обязательно присутствует имя блока или элемента, который он изменяет, а для разграничения используется один символ нижнего подчеркивания. Например, `toolbar_fixed` (модификатор `fixed` блока `toolbar`) или `toolbar__button_size_xl` (модификатор `size` в значении `xl` элемента `button` блока `toolbar`).

БЭМ позволяет гарантировать результат при внесении правок в уже существующие блоки, а как показывает опыт, большую часть времени код не пишеться, а поддерживается.

Веб-приложение представляет собой результат работы модулей, из которых оно состоит.

Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальных модулей. Поэтому, модули не должны напрямую обращаться к методам других модулей, вместо этого модули отправляют и принимают собщения. Это частный случай событийно-ориентированного программрования, который применяется при разработки пользовательских интерфейсов.

Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.

На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.

При разработке проектной работы мы будем использовать довольно популярный стек технологий:

1. Уровень библиотек: jQuery и [Underscore](http://underscorejs.org/).
2. Уровень ядра приложения: [Backbone](http://backbonejs.org/).
3. Уровень моделуй: [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) и [RequireJS](http://requirejs.org/).

Underscore это библиотека для манипулирования данными в функциональном стиле. Без этой библиотеки не обойтись при использовании Backbone. Существует более быстрая реализация Underscore – [Lo-Dash](http://lodash.com/). При желании, можете использовать ее в своей проектной работе.

Мы уже видели как можно создавать модули в JavaScript с помощью анонимных функций. Теперь когда мы умеем разбивать сложное веб-приложение на модули, то становится актуальной проблема управления зависимостями между модулями. Например, для работы контроллера «Списка писем» необходимы модули с реализацией моделей письма и коллекции писем, а так же модуль работы с представлением списка писем.

Мы рассмотрим, пожалуй, самый популярный механиз определения модулей и их зависимостей в JavaScript. Речь идет о AMD (Asynchronous Module Definition).

Вернемся к примеру с простейшей реализацией модуля в JavaScript.

~~~
var A = (function () {
        var name = 'A'; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(name);
            }
        };
    })();
~~~
{:.javascript}

В AMD этот модуль следует определить следующим образом:

~~~
define('A', function () {
    var name = 'A'; // приватная переменная
    return {
        say: function () { // публичный метод
            alert(name);
        }
    };
});
~~~
{:.javascript}

А следующая запись определяет модуль `B`, который зависит от модуля `A`.

~~~
define('B', ['A'], function (A) {
    var name = 'B'; // приватная переменная
    return {
        say: function () { // публичный метод
            A.say(); // обращение к публичному методу модуля A
            alert(name);
        }
    };
});
~~~
{:.javascript}

Интерфейсы зависимых модулей передаются в качестве параметров в функцию-конструктор определяемого модуля. AMD это не библиотека, это спецификация, и функция `define` не определена в JavaScript. Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS.

Теперь разберемся с ядром веб-приложения. Оно построено будет с использованием Backbone.

Backbone состоит из моделей (models), коллекций (collections) и представлений (views). Как вы заметили, контроллеры отсутсвуют в Backbone. Представления в Backbone, в отличие от MVC, знают что делать при взаимодействии пользователя с ними.

Данные, с которыми оперирует ваше веб-приложение, в Backbone представлены моделями, которые можно создавать, изменять, валидировать, уничтожать или сохранять на сервере. При каждом изменении данных в моделе, модель бросает событие `change`, что позволяет среагировать на эти измения, например, перерисовать часть интерфейса. Модель используется для представления сущности, а для представления множества сущностей используются коллекции. Например, на экране «Лучшие игроки» в нашей проектной работе будет выводиться список игроков, отсортированный по количеству заработанных очков. Модель — игрок, коллекция – список игроков. Backbone предоставляет методы для манипулирования коллекциями. В нашем случае потребуется упорядочить коллекцию по значению атрибута «счет» модели.

Базовым объектом в Backbone является `Events`. Любой другой объект, к которому примиксовать `Events`, унаследует возможность бросать и подписывать произвольные события. Например:

~~~
var object = {};

_.extend(object, Backbone.Events);

object.on("alert", function (msg) {
  alert("Triggered " + msg);
});

object.trigger("alert", "an event");
~~~
{:.javascript}

В этом примере мы создаем объект `object`, и с помощью метода `extend` библиотеки `Underscore` переносим в него методы из объекта `Backbone.Events`, это и есть миксование. Теперь нам доступны в объекте `object` методы `on` и `trigger`, которые используюся для подписки на событие и инициирования события соотвественно.

Объект `Events` уже примиксован к остальным объектам Backbone, например, таким как `Model` или `Collection`.

~~~
var PlayerModel = Backbone.Model.extend({
    });

var player = new PlayerModel();

player.on('change:name', function(model, name) {
    alert('Player name is ' + name);
});

player.set({name: 'Mark'});
~~~
{:.javascript}

Здесь мы создаем модель `PlayerModel`, а затем создаем экземпляр `player` созданной модели. Создаем обработчик события `change:name` для объекта `player` и устанавливаем значение атрибута `name`, используя метод `set`. Последний приведет к инициализации события `change:name`, для которого мы создали обработчик.

Обратимся к представлениям – объекты `View` в Backbone. `View` не привязаны к какому-либо шаблонизатору, например, будет достаточно того, что есть в библиотеке `Underscore`, от которой зависит Backbone. Напомню, мы будем использовать шаблонизатор Fest.

~~~
var PlayerView = Backbone.View.extend({

    tagName: "li",
    className: "score__item",
    template: fest['player'],

    events: {
        "click .button_delete": "destroy"
    },

    initialize: function () {
        this.listenTo(this.model, "change", this.render);
    },

    render: function () {
        this.$el.html(this.template(this.model.attributes));
        return this;
    },

    destroy: function () {

    }
});

var playerView = new PlayerView({
        model: player,
        id: "player-" + player.id
    });
~~~
{:.javascript}

Здесь мы создаем представление `PlayerView` и переопределяем значения по умолчанию для следующих свойств представлений. Свойство `tagName` указывает на тип HTML элемента, который будет создан, если при создании экземпляра представления не будет передан уже существующий элемент в свойстве `el`. Таким образом, у представления всегда есть элемент. Находится он в DOM или нет – неважно. Свойство `className` определяет значение аттрибута `class` для создаваемого элемента `tagName`. В свойство `template` необходимо передать функцию-шаблонизатор. Свойство `events` позволяет в удобном виде определить обработчики событий на элементах этого представления. В примере выше метод представления `destroy` будет назначен обработчиком события `click` на элементах с классом `button_delete`. Свойство `initialize` определяет функцию, которая будет вызвана при создании экземпляра представления. Здесь мы подписываемся на событие `change` модели, ассоциированной с созданным экземпляром нашего представления, а в качестве обработчика события указываем метод `render`. То есть при любых изменения в моделе, будем перерисовывать представление. Метод `listenTo`, унаследованный от объекта `Events`, позволяет создавать обработчик события и связать его с текущим контекстом. Свойство `render` определяет функцию, которая будет отвечать за перерисовку представления. В нашем случае в элемент, который связан с экземпляром представления, мы вставляем результат вызова функции-шаблонизатора.

Вашим предыдущим домашним заданием было сделать прототип веб-приложения, в котором переключение между экранами не приводило к перезагрузке страницы. Вы просто изменяли содержимое элемента страницы, при этом адрес у страницы оставался неизменным. Это неудобно по следующим причинам:

1. Чтобы попасть на определенный экран, каждый раз необходимо совершать последовательность действий, приводящих к его появлению.
2. Переходы между экранами не отображатся в истории навигации веб-браузера. При переходе на новый экран, нет возможности перейти к предыдущему по нажатию на кнопку Back веб-браузера.

Для решения этих проблем используется механизм с подменой якоря страницы. Якорь — это часть URL страницы. Начинается с символа `#` и всегда находится в конце URL. Если каждому экрану в нашем веб-приложении назначить уникальный якорь и начать отслеживать изменение этого якоря в адресе страницы, то пропадает необходимость в обработчиках события `click` для ссылок, которые осуществляют переход между экранами. Достаточно указать нужное значение якоря в артрибуте `href` и воспользоваться функционалом, который предоставляет Backbone.

~~~
<a href="#" class="js-scoreboard">Scoreboard</a>
<a href="#" class="js-game">Game</a>
<a href="#" class="js-login">Login</a>
<script>
    $('.js-scoreborad').on("click", function () { … });
    $('.js-game').on("click", function () { … });
    $('.js-login').on("click", function () { … });
</script>
~~~
{:.html}

~~~
<a href="#scoreboard">Scoreboard</a>
<a href="#game">Game</a>
<a href="#login">Login</a>
~~~
{:.html}

Для того, что бы Backbone начал отслеживать изменения якоря в адресе страницы, необходимо вызвать `Backbone.history.start()` когда документ будет уже загружен. Как это работает? Все очень просто, веб-браузер при изменении якоря бросает событие  `hashchange` от имени `window`, а Backbone начинает его слушать.

Важной частью современного веб-приложения является роутинг. Это механизм, который позволяет устанавливать связь между адресом страницы и действиями, которые необходимо выполнять каждый раз при измении адреса страницы на указанное значение. В Backbone за роутинг отвечает объект `Router`.

~~~
var Router = Backbone.Router.extend({
    routes: {
        'scoreboard': 'scoreboardAction',
        'game': 'gameAction',
        'login': 'loginAction',
        '*default': 'defaultActions'
    },
    scoreboardAction: function () {},
    gameAction: function () {},
    loginAction: function () {},
    defaultActions: function () {}
});

new Router();
~~~
{:.javascript}

В этом примере мы указываем, что при изменении якоря на значение `#scoreboard` следует выполнить метод экземпляра объекта `scoreboardAction`, при значении якоря равным `#game` – выполнить метод `gameAction`, при значении якоря равным `#login` – выполнить метод `loginAction`, а для всех остальных значений якоря – метод `defaulActions`. И неважно каким образом был изменен якорь страницы (программно или пользователь ввел его в адресной строке), роутер выполнит указанные обработчики.

Подробное изучение возможностей Backbone не является целью нашего занятия, это будет вашим домашним заданием. Поэтому мы двигаемся дальше.

Наше веб-приложение необходимо разбить на мелкие модули и определить зависимости между ними. Мы будем использовать механизм AMD и придерживаться соглашения «один модуль — один файл».

Напомню, что шаблоны Fest мы компилируем в JavaScript файлы с помощью Grunt. Поэтому необходимо изменить процедуру формирования этих файлов. Для этого в `Gruntfile.js` необходимо заменить значение параметра `template` задачи `fest` на следующее:

~~~
template: function (data) {
    return grunt.template.process(
        // 'var <%= name %>Tmpl = <%= contents %> ;',
        'define(function () { return <%= contents %> ; });',
        {data: data}
    );
}
~~~
{:.javascript}

Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS. С помощью RequireJS достаточно указать на странице всего один JavaScript файл, и все зависимые модули будут автоматически им загружены. Это очень сильно упрощает разработку. Сравните, как у нас подключались JavaScript файлы до этого:

~~~
<script src="/js/lib/jquery.js"></script>
<script src="/js/tmpl/main.js"></script>
<script src="/js/tmpl/scoreboard.js"></script>
<script src="/js/tmpl/game.js"></script>
<script src="/js/tmpl/login.js"></script>
~~~
{:.html}

И как станут подключаться теперь:

~~~
<script data-main="js/main" src="js/lib/require.js"></script>
~~~
{:.html}

Здесь мы подключаем на страницу только саму библиотеку RequireJS и указываем в атрибуте `data-main` имя файла, который следуем загрузить после того как библиотека проинициализируется. Файл `js/main.js` содержит настройки для RequireJS и определяет загрузочный модуль. В нашем случае загрузочный модуль содержит всего одну инструкцию (инициализирование `Backbone.history`) и зависит от модуля с роутером:

~~~
define([
    'router'
], function () {
    Backbone.history.start();
});
~~~
{:.javascript}

Благодаря AMD и RequireJS вам больше не нужно следить, чтобы все необходимые файлы были подключены к странице в определенном порядке. Они сделают это все за вас.

Дело за малым — настроить роутинг, реализовать представления, коллекции и модели. Это будет вашим домашним заданием. Мы подготовили структуру проекта, определили все модули-пустышки, необходимые для запуска веб-приложения. Для этого вам потребуется к репозиторию вашего проекта добавить репозиторий [github.com/eprev/frontend-stub/](https://github.com/eprev/frontend-stub/) и влить содержимое ветки v2:

~~~
$ git remote add tp https://github.com/eprev/frontend-stub.git
$ git fetch tp
$ git merge tp/v2
~~~

Теперь пришло время рассказать про конфликты в Git и лучше это сделать на примере.

~~~
$ mkdir conflict_repo && cd conflict_repo
$ git init
$ vim file.txt
$ "Hello world!"
$ git add .
$ git status
$ git commit -am "Initial commit"
$ git checkout -b "branch"
$ vim file.txt
$ Hello world! Change in "branch"
$ git status
$ git commit -am "Change in \"branch\""
$ git checkout master
$ vim file.txt
$ Hello world! Change in "master"
$ git status
$ git commit -am "Change in \"master\""
~~~

~~~
$ git merge branch
Auto-merging file.txt
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.
~~~

Так Git сообщает о возникшей проблеме, смотрим что в файле

~~~~
$ vim file.txt
<<<<<<< HEAD
Hello world! Change in "master"
=======
Hello world! Change in "branch"
>>>>>>> branch
~~~~

Здесь Git выводит оба состояния сначала, то что сохранено в текущей (HEAD) и затем что в той ветке которую вливаем в текущую.
Разрешить конфликт, означает привести к корректному состоянию и это может сделать только разработчик. После того как вы определились с тем какая из строк вам нужна, нужно закоммитить изменение без конфликта.

~~~~
$ vim file.txt
Hello world! Change in "master"
$ git status
$ git commit -am "- Conflict;"
~~~~

С конфликтами нужны быть осторожными, Git позволит закоммитить изменения и коллегам это наверняка не понравится.

При разрешении конфликтов Git, файлы `templates/*.xml` и `public_html/css/main.css` следует разрешить в пользу ваших версий, в то время как для `index.html` и `public_html/js/main.js` использовать версии из `tp/v2`. Для разрешения конфликтов в `public_html/js/tmpl/*.js` достаточно их пересобрать с помощью Grunt (`grunt fest`).

### 1.2.3 Домашнее задание
{: id="1.2.3"}

1. Самостоятельно изучить документацию Underscore, Backbone, RequireJS и БЭМ.
2. Доработать прототип в соотвествии техническому заданию.
3. Приступить к реализация игровой механики.

### 1.2.4 Техническое задание
{: id="1.2.4"}

Необходимо доработать прототип первого домашнего задания в соотвествии с организацеий [frontend-stub/v2](https://github.com/eprev/frontend-stub/tree/v2) (Grunt, Backbone, RequireJS, Fest). Достаточно подключить к репозиторию проектной работы [github.com/eprev/frontend-stub](https://github.com/eprev/frontend-stub) и объединить содержимое своего проекта с содержимым ветки v2.

1. Должны отсутствовать JavaScript ошибки при работе веб-приложения.

2. Обязательно использование БЭМ методологии в HTML и CSS.

3. Модель игрока (`public_html/js/models/score.js`) должна состоять из следующих атрибутов:

    - `name` – имя игрока (значение по умолчанию: `''`)
    - `score` – количество очков (значение по умолчанию: `0`)

4. Список игроков (`public_html/js/views/scoreboard.js`) должен состоять из 10 разных записей и программно упорядочен по убыванию атрибута `score`.

5. Переходы между экранами веб-приложения должны отражаться в истории веб-браузера, таким образом, чтобы корректно работали кнопки Back и Forward. Для этой цели к адресу веб-страницы добавляется якорь (`#`):

    - `#scoreboard` для экрана «Лучшие игроки»;
    - `#game` для основного экрана игры;
    - `#login` для экрана авторизации игры;
    - `#` для экрана «Главное меню».

6. Роутер (`public_html/js/router.js`) должен работать только с представлениями (`public_html/js/views/*.js`); представления с шаблонами (`public_html/js/tmpl/*.js`), моделями (`public_html/js/models/*.js`) и коллекциями (`public_html/js/collections/*.js`); коллекции только с моделями.

7. Экран с игрой (`#game`) и/или главный экран (`#`) должен содержать наброски (в любом виде) будущей игры.

## 1.3 Авторизация. Регистрация. Редактировани данных пользователя, AJAX, HTML form 4
{: id="1.3"}

### 1.3.1 Полезные ресурсы
{: id="1.3.1"}

### 1.3.2 Лекция
{: id="1.3.2"}

1.3.2.1 [Введение. Веб формы. Назначение и основные определения.](#1.3.2.1)

1.3.2.1.1 [Введение](#1.3.2.1.1)\\
1.3.2.1.2 [Веб формы](#1.3.2.1.2)\\
1.3.2.1.3 [Назначение и основные определения](#1.3.2.1.3)
{:.toc}

1.3.2.2 [HTML верстка. Элементы форм. Атрибуты формы и ее элементов.](#1.3.2.2)

1.3.2.2.1 [HTML верстка](#1.3.2.2.1)\\
1.3.2.2.2 [Элементы форм](#1.3.2.2.2)\\
1.3.2.2.3 [Атрибуты формы и ее элементов](#1.3.2.2.3)
{:.toc}

1.3.2.3 [Работа с формами на JavaScript. События формы и ее элементов. Работа с данными формы. Валидация данных формы.](#1.3.2.3)

1.3.2.3.1 [Работа с формами на JavaScript](#1.3.2.3.1)\\
1.3.2.3.2 [События формы и ее элементов](#1.3.2.3.2)\\
1.3.2.3.3 [Валидация данных формы](#1.3.2.3.3)
{:.toc}

1.3.2.4 [Передача данных на сервер. Рендер новой страницы. Отправка в iframe. AJAX. Обработка результатов.](#1.3.2.4)

1.3.2.4.1 [Передача данных на сервер](#1.3.2.4.1)\\
1.3.2.4.2 [Рендер новой страницы](#1.3.2.4.2)\\
1.3.2.4.3 [Отправка в iframe](#1.3.2.4.3)\\
1.3.2.4.4 [AJAX](#1.3.2.4.4)\\
1.3.2.4.5 [Обработка результатов](#1.3.2.4.5)
{:.toc}

1.5 [UX решения в формах. Возможности HTML5. Дополнительный материал для самостоятельного изучения.](#1.3.2.4)

1.3.2.5.1 [UX решения в формах](#1.3.2.5.1)\\
1.3.2.5.2 [Дополнительный материал](#1.3.2.5.2)
{:.toc}

## 1.3.2.1 Введение. Веб формы. Назначение и основные определения.
{: id="1.3.2.1"}

### 1.3.2.1.1 Введение
{: id="1.3.2.1.1"}


Всем привет! Сегодня у нас первое лекционное занятие, которое будет посвящено вопросам передачи пользовательских данных на сервер и представлению результатов обработки этих данных пользователю. Если коротко, то мы поговорим о таком широко известном и распространенном элементе интерфейса веб-приложения, как веб-форма. Любому мало-мальски знакомому с вебом человеку такой выбор темы может показаться странным именно в виду распространенности и обыденности форм. Однако, практика показывает, что многие веб-разработчики не знают всех особенностей этого механизма, либо плохо себе представляют его современные возможности. Итак, о чем же мы сегодня будем говорить?

 Как вы можете видеть, нас ждет 5 небольших модулей. В первую очередь мы немножко поговорим о применении форм и дадим основные определения. Далее познакомимся с необходимой нам HTML разметкой, узнаем о том, какие базовые возможности интерфейса форм доступны нам без применения JavaScript. Далее посмотрим, что можно делать с формами с помощью JavaScript. После этого узнаем, как можно обеспечить корректность данных, вводимых пользователем. Логичным шагом после подготовки внешнего вида и валидности данных будет создание механизма, передающего эти данные на сервер и предоставление результатов обработки пользователю. В конце лекции мы постараемся понять, что можно сделать, чтобы упростить жизнь рядового пользователя при работе с формами. Если останется время, мы поговорим о возможностях современных браузеров.


### 1.3.2.1.2 Веб формы
{: id="1.3.2.1.2"}

Итак, давайте формализуем понятие формы и разберемся, где нам пригодится такой элемент интерфейса. У классической формы есть только одно предназначение - это передача данных на сервер. И на сегодняшний день формы - это единственный кроссбраузреный инструмент, служащий этой цели. Многие из вас могут мне возразить, что можно и нужно использовать AJAX для этих целей. Да это так, если речь идет лишь о текстовых данных. Если нам необходимо передать на сервер файл (будь то текстовый документ или изображение, не так важно), мы не обойдемся без формы. Существуют и другие способы передать на сервер файл, но они либо не будут работать в некоторых современных браузера (речь идет о Flash и продуктах компании Apple), либо в старых версиях IE до сих пор широко распространенных в сети и нуждающихся в поддержке (XHR2, FileAPI). В современных веб-приложениях широко используюется частичное использование элементов форм. Любые поля, заполняемые пользователем с клавиатуры - это части формы. Формы - это удобный и очень хорошо знакомый пользователям элемент интерфейса. Очень сложно привести пример приложения, в котором мы бы не смогли найти хотя бы одну форму или ее элемент.

### 1.3.2.1.3 Назначение и основные определения
{: id="1.3.2.1.3"}

В спецификации HTML5 мы можем найти следующее определение формы:

>A form is a component of a Web page that has form controls, such as text fields, buttons, checkboxes, range controls, or color pickers. A user can interact with such a form, providing data that can then be sent to the server for further processing (e.g. returning the results of a search or calculation).

Фактически то же самое по-русски и проще для нас формулирует Википедия.

>Форма (англ. form) в HTML — раздел документа, позволяющий пользователю вводить информацию для последующей обработки системой. Синтаксически форма в HTML задаётся с помощью элемента form и в дополнение к разметке обычных элементов содержит разметку для элементов управления(англ. controls), надписей (англ. label) и других.

Не сложно заметить, что в спецификации HTML5 в определении фигурируют новые и пока еще не очень распространенные элементы форм: range controls, or color pickers. О них мы поговорим чуть позже, а пока рассмотрим несколько вариантов классических форм, использующихся в большинстве веб-приложения.

## 1.3.2.2 HTML верстка. Элементы форм. Атрибуты формы и ее элементов.
{: id="1.2"}

### 1.3.2.2.1 HTML верстка
{: id="1.3.2.2.1"}

Мы здесь пытаемся разобраться во фронтенд разработке. Как театр начинается с вешалки, так и фронтенд начинается с верстки. Сверстаем нашу форму!

Любая форма начинается с тега form, внутри которого располагаются все остальные элементы. Причем, внутри формы могут находиться не только элементы формы, но и любые другие элементы страницы, кроме еще одной формы. Вложенность форм не допускается. Итак, создадим самую простую форму, с помощью которой можно, например, заказать пиццу:

~~~
<form>
 <p><label>Имя пользователя: <input></label></p>
</form>
~~~
{:.html}

### 1.3.2.2.2 Элементы форм
{: id="1.3.2.2.2"}

На что здесь можно сразу обратить внимание? Во-первых на то, что пиццу мы пока заказать не можем, но к этому мы обязательно придем. Во-вторых, что мы сразу использовали два наиболее популярных элемента формы: input и label. Input - это самый популярный контрол любой формы. Если не указано дополнительных атрибутов, он выглядит как обычное текстовое поле. Label - это описание этого поля. В принципе, можно использовать для этих целей любой другой HTML элемент, но у label есть замечательная особенность. Если мы свяжем label и input с помощью атрибутов id и for, то все браузеры будут ставить фокус в поле при клике по соответствующему лэйблу. Это бывает очень удобно.

~~~
<form>
 <p>
<label for=”name”>Customer name: <input id=”name”></label>
 </p>
</form>
~~~
{:.html}


Добавим еще несколько элементов и кратко поговорим об их назначении.

~~~
<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <p><label>Order type: <select>
                          <option>Business</option>
                          <option>Customer</option>
                  </select>
    </label>
</p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>

 <p><label>Delivery instructions: <textarea></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
~~~
{:.html}

Посмотрим, что нового мы добавили в форму и как это новое будет себя вести. Во-первых, обратите внимание, что мы добавили несколько input и указали им атрибут type со значениями checkbox и radio. И хотя об атрибутах элементов форм мы поговорим отдельно, этот случай рассмотрим сейчас. Этот атрибут кардинально меняет поведение input, который только что представлял собой обычное текстовое поле. Именно таким образом мы можем создать радиокнопки и чекбоксы. Разница между этими элементами в том, что для одного значения поля радиокнопки предоставляют лишь один вариант значения  — именно поэтому у всех трех инпутов такого типа проставлен одинаковый атрибут name, т.е. с точки зрения пользователя набор радиокнопок представляется одним полем, для которого можно выбрать значение из заранее подготовленного списка. Каждый же из чекбоксов представляет собой отдельное поле, значение которого пользователь может отметить как выбранное.

Появилось поле, определяющие тип заказа - Order type. У радиокнопок есть отличная альтернатива для случаем, когда вариантов больше 3, или если необходима возможность выбрать сразу несколько вариантов. Тег &lt;select&gt; позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега &lt;select&gt;, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге &lt;option&gt;, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега &lt;option&gt;, который должен быть вложен в контейнер &lt;select&gt;.  Чтобы сделать список, с возможностью выбора нескольких варианов, необходима к тегу select добавить атрибут multiple.

Три радиокнопки находятся внутри элемента fieldset. Этот элемент предназначен для группирования элементов формы. Такая группировка облегчает работу с формами, содержащими большое число данных. Например, один блок может быть предназначен для ввода текстовой информации, а другой — для флажков. Чтобы объяснить пользователю назначение того или иного блока предусмотрен элемент legend. В некотором смысле legend - это аналог label для одиночного поля. Интересной особенностью блока fieldset является то, что с его помощью можно разносить элементы форм в разные места HTML страницы. Для этого служит атрибут form, в котором можно указать идентификатор нужной формы. Этот случай исключение из правила, что все элементы формы должны располагаться внутри тега form.

Для дополнительной информации, которую пользователь посчитает необходимым передать в службу доставки мы создали специальный элемент textarea. Его поведение аналогично обычному input, с той лишь разницей, что в браузере textarea будет выглядеть как поле с несколькими строками. Такой элемент используется в том случае, если мы заранее не уверены, какую именно информацию пользователю понадобиться передать на сервер. Обычно, допустимым значение textarea является любой текст.

В нижней части нашей формы мы разместили кнопку - элемент button. Этот элемент служит для инициализации отправки данных на сервер, или, как говорят, submit формы. В принципе, вместо button можно использовать и уже известный нам элемент input, у которого будет выставлен атрибут type со значением submit. Но, в отличие от этого тега, &lt;button&gt; предлагает расширенные возможности по созданию кнопок. Например, на подобной кнопке можно размещать любые элементы HTML, в том числе изображения. Используя стили можно определить вид кнопки путем изменения шрифта, цвета фона, размеров и любых других параметров.

По большому счету теперь у нас есть все базовые элементы формы, необходимые для отправки данных о заказе на сервер:

1. Текстовые поля - input[type=text], textarea
2. Радиокнопки - input[type=radio]
3. Флажки или чекбоксы - input[type=checkbox]
4. Выпадающие списки - select и options
5. Кнопки, управляющие формой - input[type=submit][type=reset], button[type=submit][type=reset]

Прежде чем попытаться заказать нашу пиццу давайте подробнее поговорим про атрибуты элементов форм и их назначение. Забегая вперед скажу, что пиццу мы не получим с той формой, что есть у нас сейчас и без атрибутов никак не обойдемся.

### 1.3.2.2.3 Атрибуты формы и ее элементов.
{: id="1.3.2.2.3"}

Модифицируем нашу форму еще раз.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname"></label></p>
 <p><label>Telephone: <input type=tel name="custtel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail"></label></p>
<p><label>Order type: <select name="custtype">
                          <option value="Business">Business</option>
                          <option value="Customer">Customer</option>
                  </select>
    </label>
</p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size value="small"> Small </label></p>
  <p><label> <input type=radio name=size value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery"></label></p>
 <p><label>Delivery instructions: <textarea name="comments"></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
~~~
{:.html}


 Атрибуты у элементов созданы для того, чтобы изменять и конкретизировать поведение этих элементов. У всех элементов есть стандартное поведение, которое проявляется без использование атрибутов. Например, button или input. Однако, в абсолютном большинстве случаев, стандартного поведения недостаточно. Разберемся, какие изменения мы внесли в форму.

Во-первых, мы установили для самого элемента формы три новых атрибута. method=”post”. Таким образом мы сообщаем браузеру о методе HTTP, в котором необходимо совершить запрос на сервер после отправки формы. Доступны два значения этого атрибута:

GET - этот метод является одним из самых распространенных и предназначен для получения требуемой информации и передачи данных в адресной строке. Пары «имя=значение» присоединяются в этом случае к адресу после вопросительного знака и разделяются между собой амперсандом (символ &). Удобство использования метода get заключается в том, что адрес со всеми параметрами можно использовать неоднократно, сохранив его, например, в закладки браузера, а также менять значения параметров прямо в адресной строке.

POST - метод post посылает на сервер данные в запросе браузера. Это позволяет отправлять большее количество данных, чем доступно методу get, поскольку у него установлено ограничение в 4 Кб. Большие объемы данных используются в форумах, почтовых службах, заполнении базы данных, при пересылке файлов и др.

enctype - Определяет способ кодирования данных формы при их отправке на сервер. Обычно устанавливать значение атрибута enctype не требуется, данные вполне правильно понимаются на стороне сервера. Но, в случае, если вы планируете отправлять на сервер файлы, его наличие обязательно. Существует несколько допустимых значений. Подробнее о них, как и о других атрибутах и их значениях можно прочитать на htmlbook.ru

action -  указывает обработчик, к которому обращаются данные формы при их отправке на сервер. Если атрибут action отсутствует, текущая страница перезагружается, возвращая все элементы формы к их значениям по умолчанию. Значением именно этого атрибута мы и связываем клиентскую и серверную сторону нашего приложения. Подробнее о вариантах отправки данных формы на сервер мы поговорим отдельно.
Однако помимо модификации самой формы, мы изменили атрибуты ее элементов. Основным изменение является добавление пар name и value ко всем элементов, данные которых должны оказаться в службе доставки. Именно эти пары значения и будут передаваться на сервер после отправки формы.

В заключении этого раздела я хотел бы обратить ваше внимание на несколько необычную конструкцию атрибутов, указанных для поля delivery. Здесь я позволю себе забежать немного вперед и рассказать о преимуществах, которые дает нам использование HTML5. Набором атрибутов type=time min="11:00" max="21:00" step="900"  для элемента input мы в современных браузерах сделали из обычного текстового поля сделали элемент, позволяющий задавать интервалы времени. При этом не написав ни строчки на JavaScript! В самом конце нашей лекции мы поговорим о HTML5 в формах о том какие возможности доступны уже сейчас, какие из них можно безопасно использовать, а на какие пока что просто интересно посмотреть.

Фактически, мы получили рабочую во всех актуальных браузерах, валидную с точки зрения HTML5 форму! Хочу только отметить, что в рамках нашей сегодняшней лекции мы говорим лишь о малой части тех возможностей, что предоставляют браузеры для работы с формами. Однако, этот тот базис, который позволит вам организовать работу с данными пользователя в вашем веб-приложении. А сейчас поговорим о том, как данные форм можно передавать на сервер.


## 1.3.2.3 Работа с формами на JavaScript. События формы и ее элементов. Работа с данными формы. Валидация данных формы.
{: id="1.3.2.3"}

### 1.3.2.3.1 Работа с формами на JavaScript
{: id="1.3.2.3.1"}


Рассмотрим основные элементы формы и средства для работы с ними. В проекте вы используете библиотеку jQuery, поэтому помимо кода на чистом JavaScript я буду приводить код jQuery.
input, textarea
Для большинства типов input значение доступно на чтение-запись в value:

~~~
var input = document.getElementById(‘input’),
textarea = document.getElementById(‘textarea’);


/*Устанавливаем новые значения для полей*/
input.value = "значение";
textarea.value = "текст";

$(input).val(‘значение jQuery’);
$(textarea).val(‘значение jQuery’);
~~~
{:.javascript}

Это самое простое и в то же время самое распространенное действие, которое обычно приходится производить над формами. Стоит обратить внимание на элемент textarea. В разметке он выглядит как обычный тег, но не стоит для него делать исключение и пользоваться свойством innerHTML, чтобы получить или установить значение такого поля формы. Оно хранит только HTML, изначально присутствовавший в элементе. Кроме того, оно не преобразует HTML-entities.

input type="checkbox", input type="radio"

Для этих элементов можно узнать или установить текущее «отмеченное» состояние.
Оно находится в свойстве checked (true/false).

~~~
if (input.checked) {
  alert("Чекбокс выбран");
}
~~~
{:.javascript}

Обратите внимание на разницу значения атрибута и свойства. Атрибут имеет значение «как указано в HTML», а свойство — логическое, в соответствие со стандартом.

~~~
<input type="checkbox" id="input" checked>

<script>
    var input = document.getElementById('input');
    console.log(input.checked); // true
    console.log(input.getAttribute('checked')); // пустая строка
</script>
~~~
{:.html}

Как некоторые из вас могут знать, у jQuery для аналогичных целей существуют так же два метода: prop и attr. prop используется для работы со свойствами, а attr для атрибутов.

~~~
<input id="input" type="checkbox" checked>

<script>
    console.log($('#input').attr('checked')); // 'checked'
    console.log($('#input').prop('checked')); // true
</script>
~~~
{:.html}

select, option
Элементы типа select, как и input, поддерживают свойство value.
Он обычно возвращает значение (value) выбранной опции, ну а в случае &lt;select multiple /&gt; — значение первой из них.

~~~
var selectedOptionValue = select.value;
~~~
{:.javascript}

Элемент селекта в JavaScript можно выбрать двумя путями: поставив значение select.value, либо установив свойство select.selectedIndex:

~~~
select.selectedIndex = 0; // первый элемент
~~~
{:.javascript}

Установка selectedIndex = -1 очистит выбор.
Опции доступны через select.options.
Если select допускает множественный выбор (атрибут multiple), то значения можно получить/установить, сделав цикл по select.options:

~~~
<form id="form" name="form">
  <select name="genre" multiple>
    <option value="blues" selected>Мягкий блюз</option>
    <option value="rock" selected>Жёсткий рок</option>
    <option value="classic">Классика</option>
  </select>
</form>
<script>
var form = document.getElementById(‘form’);
var select = form.elements.genre;
for (var i=0; i<select.options.length; i++) {
  var option = select.options[i];
  if(option.selected) {
    console.log(option.value);
  }
}
</script>
~~~
{:.html}


### 1.3.2.3.2 События формы и ее элементов.
{: id="1.3.2.3.2"}
В этой теме есть смысл отступить от правила, согласно которому мы пробуем разобраться в нативном JS коде, а после этого посмотреть на jQuery реализацию. Причиной этому служит разнообразие всевозможных событий и их поведений в различных браузерах. Поэтому, посмотрим на события с точки зрения рядового разработчика. Для примера будем использовать самый распространенный элемент: input[type=”text”].

[jsfiddle](http://jsfiddle.net/z70arqnk/)


### 1.3.2.3.3 Валидация данных формы.
{: id="1.3.2.3.3"}


Что такое и зачем нужна валидация:
1. Защита пользователя от ошибок
2. Снижение нагрузки на сервер
3. Консистентность базы

Регулярные выражения
>Регулярные выражения (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). По сути это строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов и задающая правило поиска.

html5 валидация

~~~
<input type="text" name="name" required>
<input type="email" …>
~~~
{:.html}

Почему валидация на клиенте не отменяет валидацию на сервере
JavaScript выполняется на клиенте и может быть отключен.


Проверка выполняется в зависимости от задачи:
1. Во время ввода (oninput)
2. Перед вводом (onfocus)
3. По окончании ввода (onblur)
4. Перед отправкой формы (onsubmit)
5. В случае выявленной ошибки пользователю нужно сообщить и тут есть несколько вариантов:
6. Выделение поля с ошибкой
7. Поясняющее текстовое сообщение об ошибке
8. Фокус на поле ввода с ошибкой
9. Блокировка кнопки для отправки формы

## 1.3.2.4 Передача данных на сервер. Рендер новой страницы. Отправка в iframe. AJAX. Обработка результатов.
{: id="1.3.2.4"}

### 1.3.2.4.1 Передача данных на сервер
{: id="1.3.2.4.1"}

В целом, существует три способа, передачи данных формы на сторону сервера:
1. Сабмит формы с ренедером новой страницы в новом или текущем окне
2. Сабмит формы в iframe
3. Сериализация данных формы и передача данных с помощью технологии AJAX

Первых два из них представляют собой одно и то же с точки зрения серверной стороны, но имеют различные реализации на стороне клиента. Поэтому, мы будем рассматривать их независимо друг от друга. Перед тем как мы рассмотрим каждый из способов в отдельности, поговорим немного о самом процессе и общих особенностях для всех трех случаев.
Перед тем как осуществлять какую-то передачу данных было бы здорово подготовить к этому сервер. Про организацию кода и написание обработчика данных на стороне backend вы очевидно уже знаете из смежного курса Java. Фронтенд-разработчик должен знать всего несколько вещей о сервере при работе с формами: адрес HTTP endpoint, метод HTTP, который необходимо использовать и способ кодирования данных в форме, который ожидает от него сервер. Если вы помнить мы только что рассмотрели три необходимых атрибута у тега form, однозначно определяющих эти понятия. Вызывающим наибольшее количество вопросов мне представляется выбор значения атрибута method.

Обычно к методу GET прибегают для передачи на сервер небольшого количества текстовых данных или простого набора параметров(отписаться от рассылки, потдвердить прочтение лицензионного соглашения и т.п.). Обратите ваше внимание на кэширование. GET запросы кэшируются и это очень часто вызывает определенные проблемы при разработке. Избежать кэширования запроса можно путем добавления произвольного параметра к нему. Чаще всего для этих целей используется текущее значение timestamp или случайное число. Преимуществами этого метода являетя возможность использование URL запроса в дальнейшем. Например, для размещения каких-то данных в социальных сетях.

Собственно из этих соображений вытекают преимущества и недостатки метода POST. Этот метод используется для передачи на сервер больших массивов текста, файлов, приватных данных. Использование антикэш параметров в этом методе необязательно. Такие запросы НЕ кэшируются. Здесь стоит заметить, что правильно сказать ОБЫЧНО не кэшируются или ПО СПЕЦИФИКАЦИИ не кэшируются. Есть интересное исклчение - iOS6. В этой ОС POST запрос может не добраться до вашего сервера, если это покажется нецелесообразным парням из Купертино. Проверяйте ваши формы, следите за кроссбраузерностью ваших решений. А в данном случае, если вам придется столкнуться с такой проблемой, просто используете дополнительный случайный параметр в форме по аналогии с GET антикеш параметром.


### 1.3.2.4.2 Рендер новой страницы
{: id="1.3.2.4.2"}

Итак, перейдем к первому способу отправки формы. Он самый старый и, как следствие, самый простой с точки зрения клиентской реализации. Его использование вообще не требует знаний JavaScript! Мы будем рендерить новую страницу после отправки данных на сервер. Пример, который мы разбирали в предыдущем модуле ведет себя именно так. 

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"> 
…
</form>
~~~
{:.html}

С точки зрения фронтенд разработки здесь сложно что-то добавить. После отправки данных сервер должен отренедерить новый или тот же шаблон, в зависимости от результатов, полученных при обработке данных. Этот способ уже почти ушел в прошлое. Неудобство его использование налицо - при каждой отправки формы нам нужно перерисовывать всю страницу целиком. Что можно сделать? Самое простое - открыть результаты, полученные от сервера в новом окне. Для этих целей воспользуемся еще одним атрибутом у тега form - target.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"
      target="_blank"> 
…
</form>
~~~
{:.html}

Значением _blank у этого атрибута мы указываем браузеру на то, что надо открыть новую страницу и загрузить результаты обработки формы в ней. Поведение полностью аналогично такому же атрибуту у ссылки. Однако, способ все равно еще попахивает лихими девяностыми и снежинками на страничке. Современный пользователь уже не ждет, что результат обработки формы будет представлен ему в новой вкладке браузера. Особенно этого не ждет пользователь мобильный. Что можно сделать, чтобы выправить ситуацию?


### 1.3.2.4.3 Отправка в iframe
{: id="1.3.2.4.3"}

Этот способ не сильно моложе и сложнее предыдущего, но при этом обеспечивает несколько существенных преимуществ как с точки зрения разработчика, так и пользователя. Заключается он в том, что вместе с формой на странице необходимо разместить специальный iframe, в котором и будет загружен результат обработки формы. Понятно, что в современном вебе видимый фрем на странице(если это не рекламный баннер) будет смотреться достаточно странно и архаично.  Поэтому, мы сделаем этот фрейм невидимым и пометим его идентификатором и атрибутом name. В форме же укажем соответсвующее значение уже знакомому нам атрибуту target.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"
      target="transport"> 
…
</form>
…
<iframe frameborder="0" name="transport" id="transport" class="hidden-frame"></iframe>
~~~
{:.html}

Теперь при загрузке с сервера результатов обработки формы, они будут помещены в этот iframe. При этом основная страница не будет перезагружена, а ее история останется неизменной! Остается только одна проблема, как “извлечь” данные результата и показать их пользователю. Здесь мы начнем действовать динамически, JavaScript позволяет нам это сделать. Чтобы передать информацию из фрейма в основную страницу у нас есть два способа: использовать HTML5 функциональность PostMessage или же получить доступ к контексту родительского фрейма и вызвать заранее объявленную функцию с набором параметров. В первом случае, вам необходимо загрузить в iframe код на подобии следующего:

~~~
<body>
        <script>
            var msg = {
                name: 'auth.user',
                data: {
"info": {
"name": "Artem", 
"email": "artem@gmail.com"
},
"status": "OK"
}
            };

            window.parent.postMessage(JSON.stringify(msg), '*');
        </script>
</body>
~~~
{:.html}


А в JS коде основной страницы расположить обработчик события postMessage.

~~~
$(window).on("message", postMessageDispatcher);
~~~
{:.javascript}

После загрузки результатов обработки сервером формы будет вызвана функция postMessageDispatcher с набором параметров из фрейма, о содержании этой функции вам предстоит позаботиться самостоятельно. Хочу лишь отметить, что вы должны предусмотреть обработку как успешного завершения обработки данных, так и всевозможные ошибки, но об этом чуть позже. Какие есть особенности у postMessage? О кроссбраузерности решения можно почти не беспокоится. InternetExplorer поддерживает эту технологию начиная с 8 версии. Почему почти? Потому что IE поддерживает только передачу строк в качестве тела сообщения. Именно для этого в скрипте, расположенном в iframe используется JSON сериализация данных. Одним из основных плюсов данного подхода является кроссдоменность решения.
Есть еще один способ оповестить родительское окно о том, что наш сервер что-то слелал после отправки ему формы. Разница лишь в коде, располагающемся во фрейме.

~~~
<body>
    <script type="text/javascript">
            window.parent.successSend(true);
    </script>
</body>
~~~
{:.html}

Если наш фрейм находится на том же домене, что и основное окно, мы можем получить доступ к JS контексту родителя. Функция successSend должна выполнить те же действия, что и postMessageDispatcher.

### 1.3.2.4.4 AJAX
{: id="1.3.2.4.4"}

У предыдущего способа есть один существенный недостаток - наличие iframe. Нам приходится создавать еще один HTML элемент, отдельно думать о его рендеринге, создавать отдельный шаблон на сервере для форматирования данных, полученных от сервера, заводить уникальные идентификаторы и действовать в глобальном контексте JS. Мало того, мы сильно ограничены в возможности контроля над HTTP запросом. У frame существует только одно событие - load, а это значит, что мы не можем отслеживать ошибки соединения и оповещать о них пользователя.  Все это выглядит громоздко и негибко. Решение по сути на поверхности и многие из вас уже наверняка поняли, о чем же сейчас пойдет речь. О технологии AJAX, которая в корне изменила подходы в клиентском веб-программировании и открыла для нас широчайший спектр возможностей в создании веб-приложений. С ее приходом в веб,  фронтенд разработка фактически перестала зависеть от разработки серверной части. Теперь мы можем договариваться с backend программистами лишь о пересылаемых данных и их формате. У вас будет отдельная лекция, посвященная этой теме, а в рамках этой мы рассмотрим лишь небольшой пример использования AJAX. По своей сути AJAX - это возможность сделать запрос к серверу без перезагрузки основной страницы с использованием JavaSctipt. Именно этим мы сейчас и займемся.

Ваше приложение вы разрабатываете с использованием фреймворка Backbone, использование которого подразумевает(хоть и не обязывает) использовать библиотеку jQuery. Поэтому, дальнейший рассказ об AJAX я буду вести в терминах jQuery. Вспомним, что форма - это лишь набор данных в формате “ключ”-”значение”. Ключом является содержание атрибута name у элемента формы, а значением - содержание value. Соответственно, чтобы реализовать ее AJAX отправку на сервер достаточно собрать эти пары, организовать их с использованием какого-нибудь правила и передать на сервер. В качестве такого правила чаще всего использовать JSON - JavaScript Object Notation, хотя, вам никто не запрещает воспользоваться XML нотацией. Фактически все эти действия в состоянии выполнить за нас jQuery.


~~~
$("#idForm").on("submit", function(event) {
    var url = "path/to/your/script";
    event.preventDefautlt();

    $.ajax({
           type: "POST",
           url: url,
           data: $(this).serialize(),
           success: function(data)
           {
               postDispatcher(data);
           }
         });
});
~~~
{:.javascript}

Попробуем разобраться, что мы только что сделали. Фактически весь блок кода, который вы видите на экране представляет собой вызов одной функции - $.ajax, с одним аргументом - объектом настроек. Ничего сверхъестественного. С его помощью мы делаем один запрос к серверу. Проведем аналогию с обычной отправкой формы браузером. Можно представить, что $.ajax - это и есть наша форма, а все, что внутри - содержимое формы, или, если проводить параллель с предыдущими способами - атрибуты и элементы формы.
type: "POST" -  полный аналог атрибуты формы type=”post”, определяет тип HTTP запроса.
url: "path/to/your/script" - аналог атрибута action=”path/to/your/script”, определяет серверный ресурс, отвечающий за обработку данных
data: $(this).serialize() - аналог элементов формы, имеющих атрибуты name и value. В этом месте разберемся чуть-чуть подробнее. Мы видим, что в значение поля data мы записываем результат выполнения метода serialize некого объекта $(this). Пока что я просто предлагаю вам поверить, что $(this) - это и есть наша форма, а serialize - один из ее методов. Этот методи собирает данные о всех полях формы и формирует из них объект, состоящий из пар “ключ”-”значение”. Тот самый объект, о котором я говорил в начале этого модуля. Т.е., если внутри формы есть несколько инпутов

~~~
<input name=”firstName” value=”Ivan” />
<input name=”secondName” value=”Susanin” />
~~~
{:.html}

то в наш объект с данными будет выглядеть так:

~~~
{
    “firstName”: “Ivan”,
    “secondName”: “Susanin”
}
~~~
{:.javascript}

Все предельно просто. Процесс превращения формы в такой объект и называют сериализацией формы. Остался последний параметр:
success: function(data){ postDispatcher(data);} - этой строчкой мы задаем обработчик, который сработает после успешной отправки формы. В примере, посвященному сабмиту формы в iframe аналогичная функция называлась postMessageDispatcher. На самом деле, метод $.ajax имеет много других интересных опций. С ними вы обязательно познакомитесь самостоятельно!
Осталось только разобраться, когда же будет инициализирован запрос на сервер, т.е. вызван $.ajax. Логичным кажется сделать это клику пользователя на конпку, отправки формы, однако это не является по-настоящему хорошей практикой. Вспомните, большинство форм в вебе можно отправить не только с помощью клика по кнопке, но и по нажатию Enter на клавиатуре. Вместо того, чтобы следить за двумя событиями (клик и нажатие Enter), можно следить лишь за одним - отправкой формы. Браузер дает разработчику возможность следить за событиями элементов страницы. В том числе за событиями форм. У вас будет лекция, посвященная этой теме. А пока мы остановимся только на одном, очень важном для нас событии, submit. Оно возникает при отправке формы, вне зависимости от способа, которым эта отправка инициирована. По событию submit мы делаем две вещи: во-первых, запрещаем браузеру отправлять форму на сервер стандартными средствами или, иначе говоря, прерываем стандартное действие браузера. Это действие осуществляет вызов  event.preventDefautlt(); и во-вторых, осуществляем отправку AJAX запроса на сервер - вызываем $.ajax.



### 1.3.2.4.5 Обработка результатов
{: id="1.3.2.4.5"}

+ Несколько рекомендаций по написанию функций, отвечающих за обработку результатов после отправки формы.

+ Всегда помните, что возможны несколько различных результатов обработки и не все из них будут успешными.

+ Если по каким-то причинам сервер сообщает, что обработать данные формы не удалось, нужно сообщить об этом пользователю в приемлемой форме. Если вы знаете, какие поля, вызывали проблемы на сервере, обязательно подсветите их в интерфейсе.

+ Сделайте защиту от многократной отправки формы. Многие начинающие пользователи по привычке используют двойной клик.

+ Если процесс обработки данных занимает значительное время, предусмотрите прелоудер и блокировку фомы от повторного сабмита.

+ Если вы отправляет форму с помощью AJAX, не забывайте остановить стандартную отправку формы браузером.


## 1.3.2.5 UX решения в формах. Возможности HTML5. Дополнительный материал для самостоятельного изучения.
{: id="1.3.2.5"}

### 1.3.2.5.1 UX решения в формах
{: id="1.3.2.5.1"}

Подразумевается, что в своем проекте вы должны реализовать функциональность создания и редактирования учетных записей пользователей, а так же обеспечивать процедуру их аутентификации. Обычно для этих целей служат три формы: форма регистрации, форма входа и форма редактирования личных данных пользователя.

Авторизация.
Большинство интерфейсов веб-приложений состоит как минимум из двух частей: публичной и приватной; или же поведение интерфейса имеет две основных парадигмы с соответствующими названиями. Первую видят все пользователи, вторую только авторизованные. Следовательно, чаще всего, в первой части располагается общая информация о приложении, рассказывается о том, какие функции оно выполняет и для чего служит. Вторя же часть - приватная, чаще всего персонифицирована под конкретного пользователя. Не вызывает сомнений, что, например в Почте, мы обязаны обеспечить приватность писем пользователя или дать возможность сохранять настройки внешнего вида интерфейса вне зависимости от используемого устройства. Границей, разделяющей эти две части является форма авторизации.

Если приложение, которое вы разрабатываете не подразумевает возможность работы без авторизации пользователя, то может оказаться так, что форма авторизации будет первое, что увидят ваши пользователи.

Форма авторизации является точкой входа и, как следствие, очень существенно влияет на формирование впечатления о приложении в целом. Не стоит перегружать эту форму дополнительными полями. Вполне достаточным будет организация полей идентификатора пользователя и пароля. Отличным решением является возможность авторизации с помощью существующих учетных записей в популярных сервисах(авторизация через социальные сети). Если вы решили реализовать такую возможность, подойдите крайне ответственно к выбору этих сервисов. Возможность авторизоваться с помощью учетной записи GitHub в интернет-магазине косметики выглядит по меньшей мере странно. Учитывайте географические и поло-возрастные особенности вашей аудитории.

Уже на этом этапе бывает полезно задуматься о безопасности. Здесь есть две основных проблемы: сохранение приватности передаваемых данных и опасность взлома учетных записей пользователей путем перебора пароля. По поводу первой проблемы хочется отметить, что хорошим тоном является передача всех личных данных пользователя с использованием шифрованного соединения с помощью протокола HTTPS. Даже если у вас нет технической возможности обеспечить работу всего приложения по HTTPS, это не помешает сделать несколько https endpoint для авторизации, регистрации и работы личного кабинета. Возникающие проблемы с кросс-доменными ограничениями браузеров можно решить без особых затруднений, но об этом чуть позже.

Не забывайте так же максимально усложнить жизнь злоумышленникам. Предусмотрите в вашем интерфейсе авторизации использование капчи после нескольких неудачных попыток и используйте CSRF (англ. Сross Site Request Forgery — «Межсайтовая подделка запроса», также известен как XSRF) токены. Если капчу видели все пользователи Интернет, то про CSRF стоит сказать несколько слов дополнительно. Поддержка CSRF токенов есть в большинстве современных серверных фреймворков. Если коротко, то необходимо предусмотреть скрытый input в форме, значением которого будет некий хэш, генерируемый сервером при загрузке страницы. Авторизовать пользователя можно только тогда, когда значение этого хэша при отправке формы на сервер соответствует его значению при загрузке. Вы просто убеждаетесь в том, что форму отправил именно тот пользователь, который загрузил страницу с ней.

Регистрация.

В последние несколько лет появилась тенденция использования в качестве точки входа не форму логина, а страницу регистрации. Такое решение кажется вполне логичным для молодых приложений, которым еще только предстоит завоевать мир.

Уверен, что о необходимых полях при регистрации вы сможете подумать самостоятельно. Дам лишь несколько советов. Чем меньше полей вы заставите заполнить пользователя, тем больше шанс, что у него хватит терпения пройти этот квест до конца и начать наслаждаться вашим приложением.

Не заставляйте лишний раз повторять уже введенные данные. Например, вместо дублирования поля пароль можно дать возможность увидеть, что скрывается за звездочками в этом поле.

Обязательно отмечайте поля, которые действительно необходимо заполнить для успешного завершения процесса регистрации. Это могут быть звездочки или выделенные болдом лэйблы полей и очень яркая подсветка не заполненных обязательных полей при попытке отправки формы.

Для получения данных о дате рождения или телефоне обязательно используйте сложные элементы формы. Нельзя заставлять пользователей вводить дату рождения в удобном для вас формате, не обеспечив при этом удобство этого процесса.

Если для даты рождения удачным решением выглядит группа обычных селектов, то для телефонного номера можно использовать плагин, форматирующий данные в поле по мере его заполнения. Так называемые маски и обязательный пример заполнения двусмысленных полей, телефон привычно начинать с +7, 7, 8 или вовсе без префикса.

Обязательно объясняйте пользователю ошибки, если они возникают. Подсвечивайте поле, в котором произошла ошибка, рядом выводите текст ошибки. Очень плохой практикой является использование в качестве текста ошибки фраза на подобии “поле заполнено некорректно. Пожалуйста, заполните данное поле корректно”. Ставьте фокус в ошибочное поле.

Если есть возможность, сразу же после регистрации обеспечивайте доступ пользователя к функциональности приложения. Не заставляйте его еще раз вводить пару логин/пароль, которую он только что уже вводил.

Стоит так же сказать несколько слов о безопасности форм регистрации. У всех популярных сервисов есть проблема, связанная с кибер-сквоттерами и массовыми регистрациями учетных записей. Если вы посмотрите в инспекторе форму регистрации нашей Почты, вы можете обратить внимание на то, что атрибуты name у ключевых полей представляют собой хэши, генерируемые при загрузке. Это исключает использование совсем простых способов создания множества аккаунтов. При регистрации пользователя необходимости в идентификации пользователя формы как человека значительно выше, чем при авторизации. Для этого используют привязку к социальным сетям, номеру телефона или простую капчу. Безусловно, все эти меры не являются обязательными и чаще всего делают интерфейс более громоздким и неудобным, но чаще всего на них приходится идти ради безопасности.

Существует один очень простой прием, позволяющий отсечь львиную долю регистраций с помощью ботов. Он называется honey pot - медовое пятнышко. Идея состоит в том, что большинство ботов действует в полностью автоматическом режиме и заполняют поля заранее подготовленными данными в соответствии с их названиями. Этот прием отлично срабатывает на формах обратной связи или в формах добавления комментария. Реализация крайне проста - создайте в верстке невидимый инпут с “красивым”, с точки зрения робота именем. Например, email или phone. Его верстка должна полностью соответствовать верстке обычного поля с той лишь разницей, что это поле будет скрыто средствами CSS. На сервере же предусмотрите простое условие, по которому не выполняйте предусмотренное действие, если это поле окажется заполненным. Большинство ботов не рендерят страницу целиком, а просто ищут в ней форму и заполняют поля. Работ “наступит” в вашу медовую лужицу и уже больше никогда из нее не выберется. Не забудьте только отрендерить сообщение об успешной отправки формы в таком случае!

Редактирование личных данных.

В заключении модуля коротко поговорим про Личный кабинет пользователя в вашем приложении. По большому счету, его функциональность обычно совпадает с формой регистрации с учетом некоторых особенностей. Я бы выделил две основные: интеграция с функциональностью авторизации через социальные сервисы и вопросы безопасности. Если вы даете возможность авторизоваться с помощью учетной записи стороннего сервиса, не забудьте предусмотреть возможность объединения такой учетной записи с записью, созданной более традиционными методами. Т.е. дайте пользователю возможность ввести пароль, который можно будет использовать только в вашем приложении. Или изменить данные, полученные вами из записи в социальных сетях. Если вы делаете игру, далеко не всегда юзерам будет хотеться называться так же, как и в учетной записи Facebook или использовать ту же аватарку. Это достаточно сложная задача, но ее реализация чаще всего того стоит.

В вопросах же безопасности следуют некоторые упрощения по сравнению с формой регистрации. Обычно, можно ограничится только защищенным соединением HTTPS.


### 1.3.2.5.2 Дополнительный материал для самостоятельного изучения
{: id="1.3.2.5.2"}

1. [Все, что можно сказать про формы с точки зрения HTML, сказано здесь](http://htmlbook.ru/samhtml5/formy)
2. [Спецификация HTML5 в изложении для разработчиков](http://developers.whatwg.org/forms.html#forms)
3. [JavaScript для работы с формами](http://learn.javascript.ru/forms-methods)
4. [Старый и мощный формовый движок](http://zforms.ru/)
5. [Новый формовый движок на основе BackboneJS](https://github.com/powmedia/backbone-forms)

### 1.3.3 Домашнее задание
{: id="1.3.3"}

### 1.3.4 Техническое задание
{: id="1.3.4"}
