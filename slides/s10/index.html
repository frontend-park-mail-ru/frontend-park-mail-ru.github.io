<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Продвинутые подходы разработки SPA</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="icon" type="image/png" href="/lib/favicon.png"/>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="/lib/shower/themes/technopark/styles/screen-4x3.css">
	<link rel="stylesheet" href="/lib/slides.css">

</head>
<body class="shower list">

<header class="caption">
	<h1>Продвинутые подходы разработки SPA</h1>
	<p>Технопарк, осень, 2019 г.</p>
</header>

<section class="slide first">
	<h2 class="shout">
		<small style="font-size:75%">Продвинутые подходы разработки SPA</small>
		<br/>
		<small>Слайды доступны по ссылке<br/>
			<a href="https://frontend.tech-mail.ru/">frontend.tech-mail.ru</a>
		</small>
	</h2>
</section>

<!-- Рассказ об идее использования компонентного подхода -->

<section class="slide">
	<h2 class="shout">
		<span style="font-size: 98%; line-height: 1">Немного истории</span>
		<br>
		<span style="font-size: 70%; line-height: 1; display: inline-block;">Как разрабатывали web <strong>раньше</strong>?</span>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div><code>jQuery</code>-style &mdash;</div>
		<div style="font-size: 70%;">весь код приложения в одном файле</div>
		<div style="font-size: 40%;">Zepto, KnokoutJS, etc...</div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">Такой способ удобен для украшения <em>сайта</em>, но не для разработки крупных
			<strong>web-приложений</strong></div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div>MVC &mdash;</div>
		<div style="font-size: 70%;">разделение логики от представления</div>
		<div style="font-size: 40%;">Backbone.js, Ember.js, etc...</div>
	</h2>
</section>

<section class="slide question">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="mvc.png" style="transform-origin: center;transform: translate(-50%,-40%) scale(1.3);">
	</div>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">Каждый понимал его по-своему. Не было чёткого подхода к <strong
				style="font-size: 120%;">декомпозиции</strong></div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 85%;">Как много вопросов, как мало ответов...</div>
		<ul style="font-size: 40%; line-height: 1.2; margin-top: 24px;">
			<li>Как поступать со сложными моделями?</li>
			<li>Как разбивать большие view на части?</li>
			<li>Кто должен отвечать за функциональность?</li>
		</ul>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div>Компонентный подход &mdash;</div>
		<div style="font-size: 50%;">смысл в разделении кода приложения на <strong>независимые, слабосвязанные и
			переиспользуемые</strong> компоненты
		</div>
		<div style="font-size: 30%;">слабые связи и декомпозиция</div>
	</h2>
</section>

<section class="slide question">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="simle1.jpg"
			 style="transform-origin: center;transform: translate(-50%,-40%) scale(1.2);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="component1.jpg"
			 style="transform-origin: center;transform: translate(-50%,-40%) scale(1.1);">
	</div>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 60%;">
			Компоненты могут быть <strong>достаточно сложны внутри</strong>, но они должны быть просты для использования
			<strong>снаружи</strong>
		</div>
	</h2>
</section>

<section class="slide question">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="simple2.jpg"
			 style="transform-origin: center;transform: translate(-50%,-40%) scale(1.1);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative;width: 100%; height: 82%; overflow: hidden;">
		<img class="place" src="components2.jpg"
			 style="transform-origin: center;transform: translate(-50%,-50%) scale(0.9);">
	</div>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 65%;">
			Компонентом может быть <strong>вообще всё что угодно</strong>, что выполняет какую-то функцию в вашем
			приложении
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Компоненты делят на два типа</h2>
	<blockquote>
		<p class="content">
			<strong>Dummy-компоненты</strong> &mdash; компоненты, которые либо вообще не содержат никакой логики (чисто
			визуальные компоненты), либо содержат логику, которая глубоко инкапсулирована внутри компонента
		</p>
	</blockquote>
	<p class="note">Например, компонент "Текст", компонент "Ссылка", компонент "Чекбокс"... Посложнее: компонент
		"Выезжающее меню", Компонент "Роутер".</p>
	<blockquote>
		<p class="content">
			<strong>Smart-компоненты</strong> &mdash; компоненты, которые управляют множеством других компонентов,
			содержат в себе бизнес-логику и хранят какое-то состояние
		</p>
	</blockquote>
	<p class="note">Компонент "Форма входа". Компонент "Всё приложение"</p>
</section>

<section class="slide">
	<h2>Пример dummy-компонента</h2>
	<pre class="hljs js">
		<code>class TextComponent {</code>
		<code>    constructor(el) { this.el = el || document.createElement('div') }</code>
		<code>    setText(text) {</code>
		<code>        this.text = text;</code>
		<code>        this.el.innerHTML = this.tmpl();</code>
		<code>    }</code>
		<code>    tmpl() {</code>
		<code>        return `</code>
		<code class="hljs html">            &lt;span&gt;${this.text}&lt;/span&gt;</code>
		<code>        `;</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Пример smart-компонента</h2>
	<pre class="hljs js">
		<code>class CounterComponent {</code>
		<code>    constructor(el) {</code>
		<code>        this.el = el || document.createElement('div');</code>
		<code>        this.count = 0; this.text = new TextComponent();</code>
		<code>        setInterval(() => {</code>
		<code>            this.count++;</code>
		<code>            this.text.setText(this.count);</code>
		<code>            this.el.innerHTML = this.tmpl();</code>
		<code>        }, 1000);</code>
		<code>    }</code>
		<code>    ...</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Пример smart-компонента</h2>
	<pre class="hljs js">
		<code> </code>
		<code>    ...</code>
		<code>    tmpl() {</code>
		<code>        return `</code>
		<code class="hljs html">            &lt;h1&gt;Счётчик:&lt;/h1&gt;</code>
		<code>            ${this.text.tmpl()}</code>
		<code>        `;</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Структура приложения</h2>
	<pre class="hljs html">
		<code><mark>App</mark> &mdash; smart</code>
		<code>    <mark>Router</mark> &mdash; dummy</code>
		<code>        <mark>Authorization</mark> &mdash; smart</code>
		<code>            <mark>Form</mark> &mdash; dummy</code>
		<code>                <mark>TextInput</mark> &mdash; dummy</code>
		<code>                <mark>Button</mark> &mdash; dummy</code>
		<code>        <mark>About</mark> &mdash; smart</code>
		<code>            <mark>SimpleText</mark> &mdash; dummy</code>
		<code>            <mark>Link</mark> &mdash; dummy</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Наивная реализация компонентов</h2>
	<ul lang="en">
		<li>Компонент &mdash; модуль, который содержит в себе стили этого компонента, файл-функцию с шаблоном и класс,
			который всем этим управляет
		</li>
		<li>Экземпляр компонента инициализируется с некоторыми данными (состоянием &mdash;
			<mark>state</mark>
			), которые используются при функционировании компонента
		</li>
		<li>Во время рендера, вызывается функция-шаблонизатор, она создаёт строку с HTML-кодом компонента, которая через
			<code>innerHTML</code> вставляется в DOM документа
		</li>
		<li>При изменении состояния компонента, выполняется его ререндер и он обновляет своё отображение</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Посмотрим, как это выглядит на практике
		</div>
	</h2>
</section>

<!-- Недостатки наивной реализации, дата-биндинг и реактивное программирование -->

<section class="slide">
	<h2>Недостатки наивной реализации</h2>
	<p class="medium-content"></p>
	<ul lang="en">
		<li>Много шаблонного кода</li>
		<li>При изменении одного единственного свойства происходит полная перерисовка компонентов</li>
		<li>Много лишних операций с рендером DOM</li>
		<li>
			Как следствие, низкая производительность web-приложений (вспоминаем, что всё приложение &mdash; это
			один большой компонент и учитываем два предыдущих пункта вместе)
		</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Как можно этого избежать?
		</div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Самая простая идея &mdash;
			<div style="font-size: 80%;">при изменениях state перерисовывать <strong>только то, что действительно
				необходимо</strong></div>
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Связывание данных (Data Binding)</h2>
	<blockquote>
		<p class="small-content">
			<b>Связывание данных</b> &mdash; это процесс, который устанавливает соединение между UI приложения и
			бизнес-логикой</p>
	</blockquote>
	<p class="note">Различают
		<mark>одностороннее</mark>
		и
		<mark>двустороннее</mark>
		связывание данных &mdash; <a href="/examples/data-binding/" target="_blank">пример</a></p>
</section>

<section class="slide">
	<h2>Наивное связывание данных</h2>
	<pre class="hljs js">
		<code>class TextComponent {</code>
		<code>    constructor(el) {</code>
		<code>        this.el = el || document.createElement('div');</code>
		<code>        this.el.innerHTML = this.tmpl();</code>
		<code>        this.text = '';</code>
		<code>        <mark>this._textEl = this.el.querySelector('.js-text')</mark>;</code>
		<code>    }</code>
		<code>    setText(text) {</code>
		<code>        this.text = text;</code>
		<code>        <mark>this._textEl.textContent = this.text</mark>;</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Наивное связывание данных</h2>
	<pre class="hljs js">
		<code>class TextInputComponent {</code>
		<code>    constructor(el) {</code>
		<code>        this.el = el || document.createElement('div');</code>
		<code>        this.el.innerHTML = this.tmpl();</code>
		<code>        this.value = '';</code>
		<code>        <mark>this._inputEl = this.el.querySelector('input[type=text]')</mark>;</code>
		<code>        <mark>this._inputEl.onchange</mark> = () => {</code>
		<code>            this.value = this._inputEl.value.trim();</code>
		<code>            this.emit('change', {value: this.value});</code>
		<code>        };</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Не самый хороший подход:
			<div style="font-size: 70%;">&mdash; много шаблонного кода, если необходимо связывать много элементов</div>
			<div style="font-size: 70%;">&mdash; недекларативное описание связей</div>
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Другой подход к биндингу</h2>
	<pre class="hljs html">
		<code>&lt;div></code>
		<code>    &lt;h1>Привет, &lt;span <mark>data-bind="textContent:name"</mark>>&lt;/span>&lt;/h1></code>
		<code>    &lt;input</code>
		<code>        <span hidden>&lt;input </span>type="text"</code>
		<code>        <span hidden>&lt;input </span>placeholder="Сколько вам лет?"</code>
		<code>        <span hidden>&lt;input </span><mark>data-bind="value:age"</mark></code>
		<code>    <span hidden>&lt;input </span>/></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Другой подход к биндингу</h2>
	<pre class="hljs js">
		<code>class AutoBind {</code>
		<code>    constructor(root) {</code>
		<code>        this.binded = [...root.querySelectorAll('[data-bind]')]</code>
		<code>            .map(el => ({</code>
		<code>                el,</code>
		<code>                prop: el['data-dind'].split(':')[0],</code>
		<code>                variable: el['data-dind'].split(':')[1],</code>
		<code>            }));</code>
		<code>    }</code>
		<code>    </code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Другой подход к биндингу</h2>
	<pre class="hljs js">
		<code> </code>
		<code>    getVariable(name) {</code>
		<code>        const entry = this.binded.find(({variable}) => variable === name);</code>
		<code>        return entry ? entry.el[entry.prop] : undefined;</code>
		<code>    }</code>
		<code>    setVariable(name, value) {</code>
		<code>        this.binded.forEach((entry) => {</code>
		<code>            if (entry.variable === name) {</code>
		<code>                entry.el[entry.prop] = value;</code>
		<code>            }</code>
		<code>        });</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Реактивное программирование</h2>
	<blockquote>
		<p class="medium-content">
			<b>Реактивное программирование</b> &mdash; парадигма программирования, ориентированная на потоки данных и распространение изменений.</p>
	</blockquote>
	<p>В обычном мире, чтобы посчитать значение функции, необходимо вызвать её с необходимыми аргументами</p>
	<p>В <mark>модном и молодёжном реактивном программировании</mark> функция <strong>сама пересчитается</strong>, когда её аргументы изменятся (<em>как, например, в excel</em>)</p>
</section>

<section class="slide">
	<h2>Добавим чуть-чуть реактивности</h2>
	<pre class="hljs js">
		<code>class AutoReactiveBind {</code>
		<code>    constructor(root, store) {</code>
		<code>        this.store = store;</code>
		<code>        this.binded = ... ;</code>
		<code>        this.binded.forEach(entry => {</code>
		<code>            entry.el.addEventListener('change', () => {</code>
		<code>                this.setVariable(entry.variable, entry.el[entry.prop]);</code>
		<code>            });</code>
		<code>        });</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Добавим чуть-чуть реактивности</h2>
	<pre class="hljs js">
		<code> </code>
		<code>    getVariable(name) {</code>
		<code>        return this.store[name];</code>
		<code>    }</code>
		<code>    setVariable(name, value) {</code>
		<code>        this.store[name] = value;</code>
		<code>        this.binded.forEach((entry) => {</code>
		<code>            if (entry.variable === name) {</code>
		<code>                entry.el[entry.prop] = value;</code>
		<code>            }</code>
		<code>        });</code>
		<code>    }</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			А ещё можно по-красивому биндить события
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Биндинг событий</h2>
	<pre class="hljs html">
		<code>&lt;form <mark>data-bind-event="submit:formSubmitted"</mark>></code>
		<code>    &lt;input</code>
		<code>        <span hidden>&lt;input </span>type="text"</code>
		<code>        <span hidden>&lt;input </span>placeholder="Сколько вам лет?"</code>
		<code>        <span hidden>&lt;input </span><mark>data-bind-event="input:updateAgeListener"</mark></code>
		<code>    <span hidden>&lt;input </span>/></code>
		<code>    &lt;input type="submit" /></code>
		<code>&lt;/form></code>
		<code> </code>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Посмотрим, как это выглядит на практике
		</div>
	</h2>
</section>

<!-- Идея виртуального DOM -->

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			А можно ещё круче!
		</div>
	</h2>
</section>

<section class="slide">
	<h2 class="shout">Virtual DOM</h2>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="dom-vs-virtual_dom.jpg" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.35);">
	</div>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<p class="medium-content">Главная проблема DOM &mdash; он никогда не был рассчитан для создания <mark>динамического пользовательского интерфейса</mark>.</p>
	<blockquote>
		<p>
			<b>Virtual DOM</b> &mdash; это <mark>техника и набор библиотек / алгоритмов</mark>, которые
			позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем
			создания и работы c <mark>абстракцией</mark>, имитирующей DOM-дерево
		</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="meme.jpg" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.5);">
	</div>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<p class="medium-content"></p>
	<ul>
		<li>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его <mark>легковесной копией</mark></li>
		<li>Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM</li>
		<li>При этом происходит сравнение DOM-дерева с его виртуальной копией, <mark>определяется разница и запускается перерисовка того, что было изменено</mark></li>
	</ul>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="dom-vdom.png" style="transform-origin: center;transform: translate(-48.5%,-50%) scale(0.7);">
	</div>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<div style="display: flex; justify-content: center; width: 100%" id="kek">
		<style>
			.slide #kek pre code {
				line-height: 1.5;
			}
		</style>
		<div style="width: 50%">
			<pre class="hljs js">
				<code>// before</code>
				<code>{</code>
				<code>    tagName: 'div',</code>
				<code>    classes: ['header'],</code>
				<code>    attributes: {</code>
				<code>        hidden: false</code>
				<code>    }</code>
				<code>}</code>
				<code> </code>
			</pre>
		</div>
		<div style="width: 50%">
			<pre class="hljs js">
				<code>// after</code>
				<code>{</code>
				<code>    tagName: 'div',</code>
				<code>    classes: ['header'],</code>
				<code>    attributes: {</code>
				<code>        <mark>hidden: true</mark></code>
				<code>    }</code>
				<code>}</code>
				<code> </code>
			</pre>
		</div>
	</div>
	<pre class="hljs js">
		<code>// Real DOM change</code>
		<code>div.setAttribute('hidden', 'true')</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<p class="medium-content"></p>
	<p>Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM. Но только если мы делаем это правильно. Есть две проблемы:</p>
	<ul>
		<li>когда именно делать повторную перерисовку DOM?</li>
		<li>как это сделать эффективно?</li>
	</ul>
</section>

<section class="slide">
	<h2>Когда?</h2>
	<p class="medium-content"></p>
	<p>Когда данные изменяются и нуждается в обновлении. Есть два варианта узнать, что данные изменились:</p>
	<ul>
		<li>Первый из них &mdash; «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные <mark>через регулярные промежутки времени</mark> и <mark>рекурсивно проверять все значения</mark> в структуре данных</li>
		<li>Второй вариант &mdash; «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, <mark>мы точно знаем, что нужно обновить</mark></li>
	</ul>
</section>

<section class="slide">
	<h2>Как?</h2>
	<p class="medium-content"></p>
	<p>Что делает этот подход действительно быстрым:</p>
	<ul>
		<li>Эффективные алгоритмы сравнения</li>
		<li>Группировка операций чтения/записи при работе с DOM</li>
		<li>Эффективное обновление под-деревьев</li>
	</ul>
</section>

<section class="slide">
	<h2>Virtual DOM</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="vdom.png" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.5);">
	</div>
</section>

<section class="slide question">
	<h2><a style="color: royalblue" href="https://medium.com/@abraztsov/how-virtual-dom-work-567128ed77e9" target="_blank">Как работает Virtual DOM?</a></h2>
</section>

<section class="slide">
	<h2>Пишем свой Virtual DOM</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="vdom/ubermind.jpg" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.125);">
	</div>
</section>

<section class="slide question">
	<br/>
	<br/>
	<br/>
	<br/>
	<br/>
	<a style="font-size: 180%;" href="https://github.com/8coon/tp-vdom-example">https://github.com/8coon/tp-vdom-example</a>
</section>

<section class="slide">
	<h2>Какие задачи должен решать<br/>Virtual DOM?</h2>
	<br/>
	<ul>
		<li class="next">Создавать дерево элементов на странице по шаблону</li>
		<li class="next">Изменять дерево элементов согласно обновлённому шаблону</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Создание ноды
		</div>
	</h2>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/dom-uml.png"
			 style="transform-origin: center;transform: translate(-50%, -45%) scale(0.5);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/dom-uml-h.png"
			 style="transform-origin: center;transform: translate(-50%, -45%) scale(0.5);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Функция vdom.create()</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-create.png"
			 style="transform-origin: center;transform: translate(-50%, -45%) scale(0.4);">
	</div>
</section>

<section class="slide">
	<h2>Функция vdom.create()</h2>
	<pre class="hljs js">
		<code class="next">function create(vnode) {</code>
		<div class="next">
			<code>	// Если создаём текстовый узел</code>
			<code>	if (typeof vnode === 'string') {</code>
			<code class="next">		return document.createTextNode(vnode);</code>
			<code>	}</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>	const node = document.createElement(vnode.tag);</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>	// Добавляем атрибуты</code>
			<code>	if (vnode.attrs) {</code>
			<div class="next">
				<code>		for (const [name, value] of Object.entries(vnode.attrs)) {</code>
				<code class="next">			node.setAttribute(name, value);</code>
				<code>		}</code>
			</div>
			<code>	}</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Функция create() - продолжение</h2>
	<pre class="hljs js">
		<div class="next">
			<code>	// Создаём детей</code>
			<code>	if (vnode.children) {</code>
			<div class="next">
				<code>		for (const child of vnode.children) {</code>
				<code class="next">			node.appendChild(create(child));</code>
				<code>		}</code>
			</div>
			<code>	}</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>	// Связываем виртуальный и реальный DOM</code>
			<code>	node._vnode = vnode;</code>
		</div>
		<div class="next">
			<code>	return node;</code>
			<code>}</code>
		</div>
	</pre>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Создание ноды - пример</h3>
	<pre class="hljs js">
		<code class="next">const node = vdom.create({</code>
		<code class="next">	tag: 'DIV',</code>
		<code class="next">	attrs: {</code>
		<code class="next">		style: 'background-color: red;',</code>
		<code class="next">		'tab-index': 0</code>
		<div class="next">
			<code>	}</code>
			<code>});</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>document.body.appendChild(node);</code>
		</div>
		</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Успех!
		</div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Обновление ноды
		</div>
	</h2>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Функция vdom.update()</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-update.png"
			 style="transform-origin: center;transform: translate(-50%, -45%) scale(0.4);">
	</div>
</section>

<section class="slide">
	<h2>Что могло поменяться?</h2>
	<br/>
	<ul>
		<li class="next">Количество и значения атрибутов</li>
		<li class="next">Любой из потомков</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Обновление атрибутов ноды
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Функция updateAttrs()</h2>
	<pre class="hljs js">
		<code class="next">function updateAttrs(node, prevAttrs, attrs) {</code>
		<div class="next">
			<code>	// Задаём новые значения атрибутов</code>
			<code>	if (attrs) {</code>
			<div class="next">
				<code>		for (const [name, value] of Object.entries(attrs)) {</code>
				<code class="next">			node.setAttribute(name, value);</code>
				<code>		}</code>
			</div>
			<code>	}</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>	// Удаляем старые атрибуты, которых не встретилось в новых</code>
			<code>	if (prevAttrs) {</code>
			<div class="next">
				<code>		for (const name of Object.keys(prevAttrs)) {</code>
				<div class="next">
					<code>			if (!attrs || !attrs.hasOwnProperty(name)) {</code>
					<code class="next">				node.removeAttribute(name);</code>
					<code>			}</code>
				</div>
				<code>		}</code>
			</div>
			<code>	}</code>
		</div>
		<code>}</code>
	</pre>
</section>

<section class="slide">
	<h2>Что могло поменяться?</h2>
	<br/>
	<ul>
		<li style="text-decoration: line-through; opacity: .5;">Количество и значения атрибутов</li>
		<li>Любой из потомков</li>
	</ul>
	<ul class="next">Для обновления потомков будем использовать сравнение по ключам.</ul>
	<blockquote class="next">
		Ключ — специальный строковый атрибут, семантически идентифицирующий элемент среди соседних.
	</blockquote>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Обновление дочерних нод
		</div>
		<div style="font-size: 30%;">
			<br/>
			(Возможная реализация)
		</div>
	</h2>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-1.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-2.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-3.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-4.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-5.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-6.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/tp-vdom-update-2-7.png"
			 style="transform-origin: center;transform: translate(-50%, -53%) scale(0.4);">
	</div>
</section>

<section class="slide question">
	<h3 style="font-size: 42px">Обновление дочерних нод</h3>
	<br/>
	<ul>
		<li>1 создание</li>
		<li>1 удаление</li>
		<li>2 обновления</li>
	</ul>
</section>

<section class="slide">
	<h2>Функция updateChildren()</h2>
	<pre class="hljs js">
		<code class="next">function updateChildren(node, prevChildren, children) {</code>
		<div class="next">
			<code>	const childLength = children ? children.length : 0;</code>
			<code>&nbsp;</code>
		</div>
		<code class="next">	for (let i = 0, j = 0; i < childLength; i++, j++) {</code>
		<div class="next">
			<code>		const prevVchild = prevChildren && prevChildren[j];</code>
			<code>		const vchild = children[i];</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>		const fromString = typeof prevVchild === 'string';</code>
			<code>		const toString = typeof vchild === 'string';</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>		if (fromString && toString) {</code>
			<div class="next">
				<code>			// Если старый и новый элемент -- строки</code>
				<code>			// Внимание! .childNodes, не .children!</code>
				<code>			node.childNodes[i].textContent = vchild;</code>
			</div>
			<code>		} // else if ( -- Прололжение на следующем слайде</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Функция updateChildren()<br/>(продолжение)</h2>
	<pre class="hljs js">
		<div class="next">
			<code>		} else if (</code>
			<code>			!fromString && !toString && prevVchild && prevVchild.key === vchild.key</code>
			<code>		) {</code>
			<div class="next">
				<code>			// Ключи совпадают -- можем обновить оптимально</code>
				<code>			update(node.childNodes[i], vchild);</code>
			</div>
			<code>		} else {</code>
			<div class="next">
				<code>			// Если строка превращается в элемент или наоборот</code>
				<code>			// Либо у элементов не совпали ключи</code>
				<code>			// Вставляем новую ноду перед текущей, старая нода при этом "всптывает" в конец</code>
				<code>			node.insertBefore(create(vchild), node.childNodes[i]);</code>
				<div class="next">
					<code>			// Сдвигаем индекс сравнения массива старых чайлдов</code>
					<code>			j--;</code>
				</div>
			</div>
			<code>		}</code>
			<code>	}</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Функция updateChildren()<br/>(продолжение 2)</h2>
	<pre class="hljs js">
		<code class="next">	const curChildLength = node.childNodes.length;</code>
		<div class="next">
			<code>&nbsp;</code>
			<code>	// Удаляем "лишние" узлы</code>
			<code>	for (let i = childLength; i < curChildLength; i++) {</code>
			<code class="next">		node.removeChild(node.childNodes[childLength]);</code>
			<code>	}</code>
			<code>}</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Обновление ноды - пример</h2>
	<pre class="hljs js">
		<code class="next">const node = vdom.create({</code>
		<div class="next">
			<code>	tag: 'DIV',</code>
			<code>});</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>document.body.appendChild(node);</code>
		</div>
		<div class="next">
			<code>&nbsp;</code>
			<code>dom.update(node, {</code>
			<code>	tag: 'DIV',</code>
			<code>	attrs: {</code>
		</div>
		<div class="next">
			<code>		style: 'background-color: black;',</code>
			<code>		'tab-index': 2</code>
		</div>
		<div class="next">
			<code>	}</code>
			<code>});</code>
		</div>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Всё отлично?
		</div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div style="color: indianred;">
			Нет!
		</div>
	</h2>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-component-1.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.32);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-component-2.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.32);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-component-3.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.32);">
	</div>
</section>

<section class="slide question">
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/vdom-component-4.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.32);">
	</div>
</section>

<section class="slide">
	<h3 style="font-size: 42px">При компонентном подходе<br/>возникает ряд вопросов:</h3>
	<br/>
	<ul>
		<li class="next">Как эффективно обновлять дочерние компоненты, находящиеся в шаблоне родителя?</li>
		<li class="next">Как управлять дочерним компонентом из родителя?</li>
		<li class="next">Как не сломать этим поведение дочернего компонента?</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Надо программировать
		</div>
	</h2>
</section>

<section class="slide">
	<h2>Создание ноды с компонентом</h2>
	<pre class="hljs js">
		<div class="next">
			<code>if (typeof vnode.tag === 'function') {</code>
			<code class="next">	// Создаём инстанс компонента</code>
			<code class="next">	vnode._instance = new vnode.tag(vnode.attrs, vnode.children);</code>
			<code class="next">	// Выполняем его шаблон</code>
			<code class="next">	const componentVnode = vnode._instance.render();</code>
			<code class="next">	// Создаём DOM по шаблону</code>
			<code class="next">	const node = create(componentVnode);</code>
			<code class="next">	// Записываем ссылку на элемент в компонент</code>
			<code class="next">	vnode._instance.el = node;</code>
			<code class="next">	// Сохраняем шаблон компонента для эффективного обновления</code>
			<code class="next">	node._originalVnode = node._vnode;</code>
			<code class="next">	// Записываем vdom инстанса компонента</code>
			<code class="next">	node._vnode = vnode;</code>
			<code class="next">	return node;</code>
			<code>}</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Создание компонента - пример</h2>
	<pre class="hljs js">
		<div class="next">
			<code>const node = vdom.create({</code>
			<code class="next">	tag: MyComponentClass,</code>
			<div class="next">
				<code>	// Эти атрибуты попадут прямо в инстанс компонента</code>
				<code>	attrs: {</code>
				<code>		value: 1</code>
				<code>	}</code>
			</div>
			<code>});</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Обновление ноды с компонентом</h2>
	<pre class="hljs js">
		<div class="next">
			<code>let resultVnode = vnode;</code>
			<code>if (isComponent) {</code>
			<code class="next">	// Выполняем шаблон компонента</code>
			<code class="next">	vnode = prevVnode._instance.render();</code>
			<code class="next">	// Переносим инстанс со старой ноды на новую</code>
			<code class="next">	resultVnode._instance = prevVnode._instance;</code>
			<code class="next">	// Дальше сравнивать будет именно со старым vdom шаблона, а не компонента</code>
			<code class="next">	prevVnode = node._originalVnode;</code>
			<code class="next">	// Обновляем шаблон компонента</code>
			<code class="next">	node._originalVnode = vnode;</code>
			<code>}</code>
			<code>updateAttrs(node, prevVnode.attrs, vnode.attrs);</code>
			<code>updateChildren(node, prevVnode.children, vnode.children);</code>
			<code>// Обновлем связь с virtual DOM</code>
			<code>node._vnode = resultVnode;</code>
		</div>
	</pre>
</section>

<section class="slide">
	<h2>Обновление ноды с компонентом<br/>(продолжение)</h2>
	<pre class="hljs js">
		<div class="next">
			<code>updateAttrs(node, prevVnode.attrs, vnode.attrs);</code>
			<code>updateChildren(node, prevVnode.children, vnode.children);</code>
			<code>&nbsp;</code>
			<code>// Обновлем связь с virtual DOM</code>
			<code>node._vnode = resultVnode;</code>
			<div class="next">
				<code>&nbsp;</code>
				<code>// Вызываем метод жизненного цикла компонента</code>
				<code>if (isComponent) {</code>
				<code>	resultVnode._instance.didUpdate();</code>
				<code>}</code>
			</div>
		</div>
	</pre>
</section>

<section class="slide">
	<h3 style="font-size: 42px">При компонентном подходе<br/>возникает ряд вопросов:</h3>
	<br/>
	<ul>
		<li style="text-decoration: line-through;">Как эффективно обновлять дочерние компоненты, находящиеся в шаблоне родителя?</li>
		<li style="text-decoration: line-through;">Как управлять дочерним компонентом из родителя?</li>
		<li>Как не сломать этим поведение дочернего компонента?</li>
	</ul>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%; margin-bottom: 20%">
			Решение:<br/>Жизненный цикл компонента
		</div>
	</h2>
	<div class="next" style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/mood.png"
			 style="transform-origin: center;transform: translate(-50%, -5%) scale(0.5);">
	</div>
</section>

<section class="slide">
	<h2>Жизненный цикл компонента</h2>
	<pre class="hljs js">
		<div class="next">
			<code>class Component {</code>
			<div class="next">
				<code>	constructor(attrs, children) {</code>
				<code>		this.attrs = attrs;</code>
				<code>		this.children = children;</code>
				<code>	}</code>
			</div>
			<div class="next">
				<code>	/** Вызывается после создания компонента */</code>
				<code>	didCreate() {}</code>
			</div>
			<div class="next">
				<code>	/** Вызывается перед обновлением компонента */</code>
				<code>	willUpdate(attrs, children) { /* ... */ }</code>
			</div>
			<div class="next">
				<code>	/** Вызывается после обновления компонента */</code>
				<code>	didUpdate() {}</code>
			</div>
			<div class="next">
				<code>	/** Вызывается перед уничтожением компонента */</code>
				<code>	willDestroy() {}</code>
			</div>
			<code>}</code>
		</div>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%; margin-bottom: 20%">
			willDestroy() ?
		</div>
	</h2>
	<div class="next" style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/wut.png"
			 style="transform-origin: center;transform: translate(-50%, -5%) scale(0.5);">
	</div>
</section>

<section class="slide">
	<h2>Прибираемся за компонентом</h2>
	<pre class="hljs js">
		<div class="next">
			<code>function destroy(node) {</code>
			<code class="next">	const vnode = node._vnode;</code>
			<div class="next">
				<code>&nbsp;</code>
				<code>	if (vnode) {</code>
				<div class="next">
					<code>		const isComponent = typeof vnode.tag === 'function';</code>
					<code>		// Если удаляем компонент, вызовем метод жизненного цикла</code>
					<code>		if (isComponent) {</code>
					<code class="next">			vnode._instance.willDestroy();</code>
					<code>		}</code>
				</div>
				<div class="next">
					<code>		// Удаляем детей</code>
					<code>		for (const child of node.childNodes) {</code>
					<code class="next">			destroy(child);</code>
					<code>		}</code>
				</div>
				<code>	}</code>
				<code>}</code>
			</div>
		</div>
	</pre>
</section>

<section class="slide question">
	<h2>
		<div style="font-size: 70%;">
			Теперь всё отлично?
		</div>
	</h2>
</section>

<section class="slide question">
	<h2>
		<div>
			Да.<br/>Но можно лучше!
		</div>
	</h2>
</section>

<section class="slide">
	<h2>JSX</h2>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/babel-jsx.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.7);">
	</div>
</section>

<section class="slide">
	<h2>Возможные улучшения</h2>
	<br/>
	<ul>
		<li class="next">Настроить JSX, Поддержать функцию createElement. <a href="https://youtu.be/t-Bd2RKC3Oo?t=5286">https://youtu.be/t-Bd2RKC3Oo?t=5286</a></li>
		<li class="next">Улучшить работу с DOM-атрибутами. Например, поддержать style или className.</li>
		<li class="next">Автоматически генерировать ключи там, где можем.</li>
		<li class="next">Сделать метод жизненного цикла didMount(), позволяющий перехватить момент, когда нода была вставлена на страницу.</li>
		<li class="next"><strong>Поддержать события.</strong></li>
	</ul>
</section>

<section class="slide">
	<h2>Поддержка событий.</h2>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/react-events.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(1.1);">
	</div>
</section>

<section class="slide">
	<h2>Демо-приложение</h2>
	<div style="position:relative; width: 100%; height: 75%;">
		<img class="place" src="../s10/vdom/demo-app.png"
			 style="transform-origin: center;transform: translate(-50%, -46%) scale(0.8);">
	</div>
</section>

<section class="slide">
	<h2 class="shout">Перерыв</h2>
</section>

<!-- ВЕБ-КОМПОНЕНТЫ -->

<section class="slide">
	<h2 class="shout">Веб-компоненты</h2>
</section>

<section class="slide">
	<h2>Современные веб-компоненты</h2>
	<blockquote>
		<p class="small-content"><b>Веб-компоненты</b> &mdash; технология, которая позволяет создавать многократно
			используемые компоненты в веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и
			<mark>не требуют дополнительных библиотек для работы</mark>
			. Модель веб-компонентов подразумевает инкапсуляцию и совместимость отдельных элементов
		</p>
		<p class="note">На данный момент частичная поддержка существует в браузерах Chrome, Firefox, Opera и Safari. Для
			браузеров не поддерживающих веб-компоненты реализованы полифиллы</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Современные веб-компоненты</h2>
	<p>Веб-компоненты включают в себя четыре технологии:</p>
	<ul>
		<li>Shadow DOM v1 &mdash; <a
				href="https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom" target="_blank">developers.google.com</a>
		</li>
		<li>HTML Templates &mdash; <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template"
									  target="_blank">MDN</a></li>
		<li>Custom Elements API v1 &mdash; <a href="https://github.com/shawnbot/custom-elements" target="_blank">описание</a>
		</li>
		<li>HTML Imports &mdash; <a href="https://htmlhook.ru/html-imports.html" target="_blank">htmlhook.ru</a></li>
	</ul>
</section>


<!--shadow dom-->

<section class="slide question" style="background-color:#e6e6e6;">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="shadow.jpg" style="transform-origin: center;transform: translate(-50%,-45%) scale(0.9);">
	</div>
</section>

<section class="slide">
	<h2>Shadow DOM v1</h2>
	<blockquote>
		<p class="small-content"><b>Shadow DOM</b> &mdash; инструмент инкапсуляции HTML. Shadow DOM позволяет изменять
			внутреннее представление HTML элементов, оставляя внешнее представление неизменным</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Shadow DOM v1</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="shadow-dom-ciuse.png" style="transform-origin: center;transform: translate(-50.3%,-50%) scale(0.8);">
	</div>
</section>

<section class="slide">
	<h2><code>&lt;input type="range"></code></h2>
	<input type="range" style="transform: scale(3) translateX(-50%); margin-left: 50%;">
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="shadow-user-agent.png" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.5);">
	</div>
</section>

<section class="slide">
	<h2>Shadow DOM</h2>
	<pre class="hljs js">
		<code>// Shadow DOM v0</code>
		<code>const root = element.createShadowRoot();</code>
		<code> </code>
		<code>// Shadow DOM v1</code>
		<code>const root = element.attachShadow({ <mark>mode: 'open'</mark> });</code>
		<code>// const root = element.attachShadow({ <mark>mode: 'close'</mark> });</code>
		<code> </code>
		<code>element.shadowRoot === root; // true</code>
		<code> </code>
		<code><mark>root.innerHTML</mark> = ' ... ';</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Shadow DOM (<a href="/examples/web-components/shadow.html" target="_blank">пример 1</a>)</h2>
	<pre class="hljs html">
		<code>&lt;!-- html --></code>
		<code>&lt;div id="element1"></code>
		<code>    &lt;h2>Subheader h2&lt;/h2>   &lt;p>lorem ipsum&lt;/p></code>
		<code>    &lt;h2>Subheader h2&lt;/h2>   &lt;p>Lorem ipsum dolor sit.&lt;/p></code>
		<code>&lt;/div></code>
	</pre>
	<pre class="hljs js">
		<code>const root1 = element1.attachShadow({ <mark>mode: 'open'</mark> });</code>
		<code>root1.innerHTML = `</code>
		<code class="hljs html">    &lt;section></code>
		<code class="hljs html">        &lt;h1>Main header&lt;/h1></code>
		<code class="hljs html">        <mark>&lt;slot>&lt;/slot></mark></code>
		<code class="hljs html">    &lt;/section></code>
		<code>`;</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Shadow DOM (<a href="/examples/web-components/shadow.html" target="_blank">пример 1</a>)</h2>
	<pre class="hljs html">
		<code>&lt;div id="element1"></code>
		<code>    &lt;section></code>
		<code>        &lt;h1>Main header&lt;/h1></code>
		<code>        &lt;h2>Subheader h2&lt;/h2>   &lt;p>Lorem ipsum.&lt;/p></code>
		<code>        &lt;h2>Subheader h2&lt;/h2>   &lt;p>Lorem ipsum dolor sit.&lt;/p></code>
		<code>    &lt;/section></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Shadow DOM (<a href="/examples/web-components/shadow.html" target="_blank">пример 2</a>)</h2>
	<pre class="hljs html">
		<code>&lt;!--html--></code>
		<code>&lt;div id="element2"></code>
		<code>    &lt;span slot="header">Header&lt;/span></code>
		<code>    &lt;span slot="content">Lorem ipsum dolor sit.&lt;/span></code>
		<code>&lt;/div></code>
	</pre>
	<pre class="hljs js">
		<code>const root2 = element2.attachShadow({ <mark>mode: 'open'</mark> });</code>
		<code>root2.innerHTML = `</code>
		<code class="hljs html">    &lt;section></code>
		<code class="hljs html">        &lt;h1> <mark>&lt;slot name="header">&lt;/slot></mark> &lt;/h1></code>
		<code class="hljs html">        &lt;p> <mark>&lt;slot name="content">&lt;/slot></mark> &lt;/p></code>
		<code class="hljs html">    &lt;/section></code>
		<code>`;</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Shadow DOM (<a href="/examples/web-components/shadow.html" target="_blank">пример 2</a>)</h2>
	<pre class="hljs html">
		<code>&lt;div id="element2"></code>
		<code>    &lt;section></code>
		<code>        &lt;h1> &lt;span>Header&lt;/span> &lt;/h1></code>
		<code>        &lt;p> &lt;span>Lorem ipsum dolor sit.&lt;/span> &lt;/p></code>
		<code>    &lt;/section></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Shadow DOM</h2>
	<pre class="hljs html">
		<code>#shadow-root</code>
		<code>&lt;style></code>
		<code>    :host {</code>
		<code>        opacity: 0.4;</code>
		<code>        will-change: opacity;</code>
		<code>        transition: opacity 300ms ease-in-out;</code>
		<code>    }</code>
		<code>    :host(:hover) {</code>
		<code>        opacity: 1;</code>
		<code>    }</code>
		<code>    ::slotted(&lt;selector>) { ... }</code>
		<code>&lt;/style></code>
		<code> </code>
	</pre>
</section>


<!--html templates-->

<section class="slide">
	<h2>HTML Templates</h2>
	<blockquote>
		<p class="small-content"><b>HTML Templates</b> &mdash; это механизм для отложенного рендера клиентского
			контента, который не отображается во время загрузки, но может быть инициализирован при помощи JavaScript.
			Содержимое тегов <code>&lt;template></code> парсится браузером, но отрабатывает только в момент вставки
			шаблона в DOM</p>
	</blockquote>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="html-tmpl-ciuse.png" style="transform-origin: center;transform: translate(-50.3%,-50%) scale(0.8);">
	</div>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs html">
		<code>&lt;!--html--></code>
		<code>&lt;template id="tmpl"></code>
		<code>    &lt;h3>Заголовок: &lt;slot name="title">&lt;/slot>&lt;/h3></code>
		<code>    &lt;img src="image.png" alt="My Image"></code>
		<code>    &lt;script></code>
		<code>        alert(1);</code>
		<code>    &lt;/script></code>
		<code>&lt;/template></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs html">
		<code>&lt;!--html--></code>
		<code>&lt;div id="source"></code>
		<code>    &lt;span slot="title">Hello, World!&lt;/span></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs js">
		<code>const target = document.getElementById('source');</code>
		<code>const tmpl = document.getElementById('tmpl');</code>
		<code> </code>
		<code>// two way</code>
		<code>target.appendChild(tmpl.content.cloneNode(true));</code>
		<code>/*  or  */</code>
		<code>target.appendChild(document.importNode(tmpl.content, true));</code>
		<code> </code>
	</pre>
	<p class="note">Ссылка на &mdash; <a href="/examples/web-components/templates.html" target="_blank">пример</a></p>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs html">
		<code>&lt;!-- result --></code>
		<code>&lt;div id="source"></code>
		<code>    &lt;span slot="title">Hello, World!&lt;/span></code>
		<code> </code>
		<code>    &lt;h3>Заголовок: &lt;slot name="title">&lt;/slot>&lt;/h3></code>
		<code>    &lt;img src="image.png" alt="My Image"></code>
		<code>    &lt;script></code>
		<code>        alert(1);</code>
		<code>    &lt;/script></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs js">
		<code>const target = document.getElementById('source');</code>
		<code>const tmpl = document.getElementById('tmpl');</code>
		<code> </code>
		<code>/*  or  */</code>
		<code>const root = target.<mark>attachShadow</mark>({mode:'open'});</code>
		<code>root.appendChild(tmpl.content.cloneNode(true));</code>
		<code> </code>
	</pre>
	<p class="note">Ссылка на &mdash; <a href="/examples/web-components/templates.html" target="_blank">пример</a></p>
</section>

<section class="slide">
	<h2>HTML Templates</h2>
	<pre class="hljs html">
		<code>&lt;!-- result --></code>
		<code>&lt;div id="source"></code>
		<code>    &lt;h3>Заголовок: &lt;slot name="title">Hello, World!&lt;/slot>&lt;/h3></code>
		<code>    &lt;img src="image.png" alt="My Image"></code>
		<code>    &lt;script></code>
		<code>        alert(1);</code>
		<code>    &lt;/script></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>


<!--custom elements-->

<section class="slide">
	<h2>Custom Elements API v1</h2>
	<blockquote>
		<p class="small-content"><b>Custom Elements API</b> &mdash; позволяют создавать и определять API
			<mark>собственных</mark>
			HTML элементов
		</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Custom Elements API v1</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="custom-elements-ciuse.png"
			 style="transform-origin: center;transform: translate(-50.3%,-50%) scale(0.8);">
	</div>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>customElements.define(tagName, constructor, options);</code>
		<code> </code>
		<code>class MyHTMLElement extends HTMLElement {}</code>
		<code>window.customElements.define('my-element', MyHTMLElement);</code>
		<code> </code>
	</pre>

	<pre class="hljs html">
		<code>&lt;!-- PROFIT --></code>
		<code>&lt;my-element>&lt;/my-element></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>// "super" is not a valid custom element name</code>
		<code>document.createElement('super')</code>
		<code>                instanceof HTMLUnknownElement; // true</code>
		<code> </code>
		<code>// "x-super" is a valid custom element name</code>
		<code>document.createElement('x-super')</code>
		<code>                instanceof HTMLElement; // true</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements styling</h2>
	<pre class="hljs css">
		<code>x-super:<mark>defined</mark> {</code>
		<code>    display: block;</code>
		<code>}</code>
		<code>x-super:not(:defined) {</code>
		<code>    display: none;</code>
		<code>}</code>
		<code>x-super {</code>
		<code>    color: black;</code>
		<code>}</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>customElements.define('bigger-img', class extends Image {</code>
		<code>    constructor(width=50, height=50) {</code>
		<code>        super(width * 10, height * 10);</code>
		<code>    }</code>
		<code>}, {extends: 'img'});</code>
		<code> </code>
	</pre>

	<pre class="hljs html">
		<code>&lt;!-- This &lt;img> is a bigger img. --></code>
		<code>&lt;img is="bigger-img" width="15" height="20"></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>const BiggerImage = customElements.get('bigger-img');</code>
		<code>const image = new BiggerImage(15, 20);</code>
		<code>console.assert(image.width === 150);</code>
		<code>console.assert(image.height === 200);</code>
		<code> </code>
		<code>customElements.whenDefined('bigger-img')</code>
		<code>    .then(() => {</code>
		<code>        console.log('`bigger-img` ready!');</code>
		<code>    });</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>customElements.define('my-element', class extends HTMLElement {</code>
		<code>    constructor() {</code>
		<code>        super();</code>
		<code>    }</code>
		<code>    <mark>connectedCallback</mark>() { ... }</code>
		<code>    <mark>disconnectedCallback</mark>() { ... }</code>
		<code>    <mark>adoptedCallback</mark>() { ... }</code>
		<code>    ...</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>    ...</code>
		<code>    get disabled() {</code>
		<code>        return this.hasAttribute('disabled');</code>
		<code>    }</code>
		<code>    set disabled(value) {</code>
		<code>        if (value) {</code>
		<code>            return this.setAttribute('disabled', '');</code>
		<code>        }</code>
		<code>        this.removeAttribute('disabled');</code>
		<code>    }</code>
		<code>    ...</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>Custom Elements</h2>
	<pre class="hljs js">
		<code>    ...</code>
		<code>    <mark>attributeChangedCallback</mark>(attrName, oldVal, newVal) { ... }</code>
		<code>    static get <mark>observedAttributes</mark>() {</code>
		<code>        return ['open', 'disabled'];</code>
		<code>    }</code>
		<code>});</code>
		<code> </code>
	</pre>
</section>


<!--html imports-->

<section class="slide">
	<h2>HTML Imports</h2>
	<blockquote>
		<p class="small-content"><b>HTML Imports</b> &mdash; позволяют импортировать фрагменты разметки из других файлов
			без использования AJAX и похожих способов</p>
	</blockquote>
</section>

<section class="slide">
	<h2>HTML Imports</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="html-imports-ciuse.png"
			 style="transform-origin: center;transform: translate(-50.3%,-50%) scale(0.8);">
	</div>
</section>

<section class="slide">
	<h2>HTML Imports</h2>
	<pre class="hljs html">
		<code>&lt;!-- imported.html --></code>
		<code>&lt;div id="loader"></code>
		<code>    &lt;span>Loading...&lt;/span></code>
		<code>&lt;/div></code>
		<code>&lt;script></code>
		<code>    window.Module = class M { ... }</code>
		<code>&lt;/script></code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>HTML Imports</h2>
	<pre class="hljs html">
		<code>&lt;!-- index.html --></code>
		<code>&lt;head></code>
		<code>    &lt;link rel="<mark>import</mark>" href="<mark>imported.html</mark>"></code>
		<code>&lt;/head></code>
		<code> </code>
	</pre>
	<pre class="hljs js">
		<code>const link = document.querySelector('link[rel=import]');</code>
		<code>const content = link.<mark>import</mark>.querySelector('#loader');</code>
		<code>document.body.appendChild(content.cloneNode(true));</code>
		<code>const module = new Module();</code>
		<code> </code>
	</pre>
</section>

<section class="slide">
	<h2>HTML Imports</h2>
	<pre class="hljs html">
		<code>&lt;!-- imported.html --></code>
		<code>&lt;style <mark>scoped</mark>></code>
		<code>    div { font-weight: 900; }</code>
		<code>&lt;/style></code>
		<code>&lt;div id="loader"></code>
		<code>    &lt;span>Loading...&lt;/span></code>
		<code>&lt;/div></code>
		<code> </code>
	</pre>
</section>

<section class="slide question">
	<h2><a style="color: royalblue" href="/examples/web-components/fancy-progress/" target="_blank">Пример</a></h2>
</section>

<section class="slide question">
	<h2><a style="color: royalblue" href="https://www.polymer-project.org/" target="_blank">Polymer</a></h2>
</section>

<!--THE END-->

<section class="slide">
	<h2>Полезные ссылки</h2>
	<ul lang="en">
		<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/customelements"
			   target="_blank">Custom Elements v1</a> на developers.google.com
		</li>
		<li>Shadow DOM <a href="https://frontender.info/shadowdom/" target="_blank">на frontender.info</a> и <a
				href="https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom" target="_blank">на
			developers.google.com</a></li>
		<li>Статьи на хабре про <a href="https://habrahabr.ru/post/210058/" target="_blank">веб-компоненты</a>, про <a
				href="https://habrahabr.ru/post/180377/" target="_blank">Shadow DOM</a> (немного устаревшие)
		</li>
		<li><a href="https://learn.javascript.ru/webcomponents" target="_blank">Веб-компоненты: взгляд в будущее</a> на
			learn.javascript.ru (устарело)
		</li>
		<li><a href="https://www.webcomponents.org/" target="_blank">webcomponents.org</a></li>
		<li><a href="http://www.lucaongaro.eu/blog/2012/12/02/easy-two-way-data-binding-in-javascript/" target="_blank">Easy
			Two-Way Data Binding in JavaScript</a></li>
		<li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank">Описание принципа работы VDOM</a> и <a
				href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060" target="_blank">статья
			на медиуме</a></li>
	</ul>
</section>

<section class="slide">
	<h2 class="shout">Всем спасибо!</h2>
</section>

<div class="progress"></div>
<script src="/lib/shower/shower.min.js"></script>
<script src="/lib/hljs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/reload/reload.js"></script>

</body>
</html>
