# Преамбула

Предполагается, что студент имеет базовые знания веб-технологий (HTML, CSS, JavaScript) и практические навыки решения задач с помощью базовых алгоритмов и структур данных.

Ресурсы для самостоятельного изучения:

1. Влад Мержевич. [Самоучитель HTML4](http://htmlbook.ru/samhtml) // 2010.
2. Влад Мержевич. [Самоучитель CSS](http://htmlbook.ru/samcss) // 2010.
3. Илья Кантор. [Современный учебник JavaScript](http://learn.javascript.ru) // 2013.

# 1 Архитектура

## 1.1 Знакомство, инструменты, настройка окружения

### Лекция

Меня зовут Антон Епрев, в компании Mail.ru я руковожу группой фронтенд разработчиков проекта «Почта». Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Иван Чашкин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Иван занимается разработкой веб-версии почты для смартфонов, знает если не абсолютно все, то безусловно очень много про особенности мобильных браузеров.

Курс фронтенд разработки состоит из трех модулей, восьми совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), трех контрольных рубежей и презентации проекта. В общей сложности курс состоит из двенадцати занятий.

Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.

Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.

Дадим определение основных понятий.

Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [[Википедия](http://ru.wikipedia.org/wiki/Веб-приложение)].

Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – front-end, тогда как часть веб-приложения, работающая на стороне сервера, называется back-end.

В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, DOM, Events, Host Objects, AJAX; получите необходимую базу знаний о работе браузера (десктоп, смартфоны, планшеты), клиент-серверной архитектуре, архитектуре веб-приложений (события, модули, организации кода) и приобретёте  навыки работы с DOM, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.

Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для многопользовательской игры с использованием смартфона в качестве игрового контроллера.

На протяжении всего курса у нас будет три контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопроваждается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. По итогам трех рубежей каждый из вас наберет определенное количество баллов.

Каковы критерии оценки при прохождении рубежного контроля?

1. Соответствие результата предъявляемым требованиям.
2. Оптимальность предлагаемого решения.
3. Практичность решения (возможность дальнейшего применения в работе).
4. Качество оформления результатов работы.
5. Доказательность аргументации при защите работы.

Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).

Вводная часть занятия окончена. Переходим в основной части.

Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом [Node.js](http://nodejs.org) появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является [самым популярным языком программирования](http://adambard.com/blog/top-github-languages-for-2013-so-far/) среди создаваемых на GitHub проектов.

Вместе с дистрибутивом Node.js распространяется и [NPM](https://npmjs.org) (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.

В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на [GitHub](https://github.com/eprev/frontend).

У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является [Grunt](http://gruntjs.com/). Его без труда может установить каждый, воспользовавшись NPM.

Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. [Fest](https://github.com/mailru/fest) обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.

Полезные ресурсы:

1. Scott Chacon. [Pro Git](http://git-scm.com/book) // 2009.
2. [Grunt: Getting started](http://gruntjs.com/getting-started) // 2013.
3. Документация по [`package.json`](https://npmjs.org/doc/files/package.json.html).

### Практика

Создайте директорию для проекта.

```
$ mkdir ИМЯ-ПРОЕКТА
```

Создайте [`package.json`](https://npmjs.org/doc/files/package.json.html).

```
$ npm init
```

Установите Grunt и `grunt-contrib-connect`.

```
$ npm install grunt-cli -g
$ npm install grunt grunt-contrib-connect --save-dev
```

Создайте `Gruntfile.js` и настройте таск `connect`.

```
$ grunt connect
Running "connect:server" (connect) task
Waiting forever...
Started connect web server on http://localhost:8080
```

Установите `grunt-fest` и настройте таск `fest`.

```
$ npm install grunt-fest --save-dev
```

### Домашнее задание

Создатать прототип веб-приложения.

## 1.2 Архитектура веб-приложений

- Глобальная область видимости.
- Модули.
- БЭМ.
- [PubSub](http://en.wikipedia.org/wiki/Publish–subscribe_pattern).
- [MVC](http://ru.wikipedia.org/wiki/Model-View-Controller).
- [Backbone](http://backbonejs.org).

Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Глобальные переменные являются свойствамии объекта `window`. Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства `window`. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.

```JavaScript
var foo = 1;
(function (window, undefined) {
    var foo = 2;
    alert(foo); // 2
})(window);
alert(foo); // 1
```

Как устроено сложное веб-приложение?

Уровень библиотек. 
Уровень ядра приложения.
Уровень модулей.

> Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [[Википедия](http://ru.wikipedia.org/wiki/Модуль_(программирование\))].

Модуль веб-приложения состоит из HTML, CSS и JavaScript – блок в терминологии БЭМ. Модули характеризуются [связанностью](http://ru.wikipedia.org/wiki/Связанность_(программирование\)). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные. 

Веб-приложение представляем собой результат работы модулей из которых оно состоит.

Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальные модули.

Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.

На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.

Литература:

1. Addy Osmani. [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) // 2011.
2. Эдди Османи. [Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru) // 2011.
3. Addy Osmani. [Developing Backbone.js Applications](http://addyosmani.github.io/backbone-fundamentals/) // 2013.

ДЗ:

1. Реализовать проект на Backbone (определить models/collections и views).
2. Организовать подключение ресурсов через AMD.
3. Организовать сборку ресурсов для production и development окружения.

# 2 DOM & AJAX

## 2.1 Работа с DOM, Events

- [DOM](https://developer.mozilla.org/en/docs/DOM).
- [Events](http://www.w3.org/TR/DOM-Level-2-Events/events.html).
- [Событийно-ориентированное_программирование](http://ru.wikipedia.org/wiki/Событийно-ориентированное_программирование).
- [Host Objects](http://es5.github.io/#x4.3.8).

ДЗ:

1. Реализация игровой механики (на протяжении последующих домашних заданий в этом модуле).

## 2.2 Сетевое взаимодествие

- HTTP.
- AJAX.
- CORS.
- WebSockets.

Литература:

1. Tiffany Brown. [Introduction to XMLHttpRequest Level 2](http://dev.opera.com/articles/view/xhr2/) // 2012.
2. Armin Ronacher. [Websockets 101](http://lucumr.pocoo.org/2012/9/24/websockets-101/) // 2012.

ДЗ:

1. Наладить взаимодествие с сервером с помощью AJAX.

## 2.3 Хранение данных на клиенте

- Cookies.
- [Storage](http://www.html5rocks.com/en/features/storage).

ДЗ:

1. Организовать хранение пользовательских настроек на клиенте.
2. Сохранять результаты игры на клиенте, при остуствии связи с сервером.

# 3 Отладка и мобильный веб

## 3.1 Web Inspector и препроцессоры CSS

- [Sass](http://sass-lang.com).
- [Source Maps](https://developers.google.com/chrome-developer-tools/docs/css-preprocessors).

ДЗ:

1. Перевести CSS на Sass.

## 3.2 Производительность

- HTTP Cache.
- HTTP Waterfall.
- Reflow/Repaint.
- Web workers.
- [App Cache](http://www.html5rocks.com/en/tutorials/appcache/beginner/).
- Prefetching.
- CSS специфичность.

ДЗ:

1. Сделать прогресс-бар загрузки ресурсов.
2. Настроить HTTP заголовки, отвечающие за кеширование ресурсов.

## 3.3 Возможности смартфонов

- Акселерометр.
- Гироскоп.
- Тач-события.

Литература:

1. Chris Wilson, Paul Kinlan. [Touch And Mouse. Together Again For The First Time](http://www.html5rocks.com/en/mobile/touchandmouse/) // 2013.

ДЗ:

1. Сделать джойстик для смартфонов и организовать взаимодействие на websockets между экранами приложения.

# Полезные ссылки

1. [Build New Games. Open Web techniques for cutting-edge game development](http://buildnewgames.com).
